<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | 曾经渐行远，未免心戚戚]]></title>
  <link href="http://aluenkinglee.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://aluenkinglee.com/"/>
  <updated>2014-03-14T17:19:47+08:00</updated>
  <id>http://aluenkinglee.com/</id>
  <author>
    <name><![CDATA[Aluen King Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MySql交换两列]]></title>
    <link href="http://aluenkinglee.com/blog/2013/06/14/mysqljiao-huan-liang-lie/"/>
    <updated>2013-06-14T15:35:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2013/06/14/mysqljiao-huan-liang-lie</id>
    <content type="html"><![CDATA[<p>事情的起因是这个发现数据库中出现了某两列数据正好颠倒了，大部分数据都是正常的，
这些错误的原因是数据源有问题，今天在进一步的做标签聚类的时候分析的时候发现这
些占很小比例的误差，辛亏发现了，否则做出来的结果有可能会郁闷很久。</p>

<p><code>
select id,place_lat,place_lon from `nearbyinfo` where `nearbyinfo`.`place_lat`&gt;0;
</code></p>

<p>正常的数据都是&lt; <code>39.xxx</code>, <code>160.2xxx</code> &gt;之间，如图所示:
<!--more--></p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2013-06-14-mysqljiao-huan-liang-lie/11.png?raw=true" alt="正常数据" title="正常数据" /></p>

<p>但是幸好及时发现了存在这样的数据，</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2013-06-14-mysqljiao-huan-liang-lie/12.png?raw=true" alt="异常数据" title="异常数据" /></p>

<p>一开始想的是想写sql语句试着把这两栏的数据给交换过来，可是sql太渣…然后就想着找
到这些ID和他们的坐标值（都已经出来了），然后用python读出来写成update的语句，
然后在执行一下就可以了，这也太…</p>

<p>辛亏最终还是找到了，在这还是完整的说明一下吧。首先创建一个表，在Mysql中</p>

<p><code>
CREATE DATABASE  IF NOT EXISTS `weibodata` 
USE `weibodata`;
DROP TABLE IF EXISTS `test`;
CREATE TABLE `test` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `a` varchar(45) DEFAULT NULL,
  `b` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
LOCK TABLES `test` WRITE;
INSERT INTO `test` VALUES (1,'-1','4'),(2,'3','2');
UNLOCK TABLES;
</code></p>

<p>所以看起来会是这个样子:</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2013-06-14-mysqljiao-huan-liang-lie/12.png?raw=true" alt="交换之前" title="交换之前" /></p>

<p>然后执行下面的语句，会发生第二行swap了</p>

<p><code>
UPDATE test t1,test t2 SET t1.a=t1.b,t2.b=t2.a where t1.id =t2.id and t1.a&gt;0;
</code></p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2013-06-14-mysqljiao-huan-liang-lie/12.png?raw=true" alt="交换之后" title="交换之后" /></p>

<p>在尝试一下就会变成原样。</p>

<p>问题解决了。</p>

<p><code>
select id,place_lat,place_lon from nearbyinfo where place_lat &gt;100;
UPDATE nearbyinfo t1,nearbyinfo t2 SET t1.place_lat=t1.place_lon,t2.place_lon=t2.place_lat where t1.id = t2.id and t1.place_lat&gt;100;
select id,place_lat,place_lon from nearbyinfo where id in (1025,4974,4814,2685);
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python处理带有时区的的字符串]]></title>
    <link href="http://aluenkinglee.com/blog/2013/04/16/pythonchu-li-dai-you-shi-qu-de-de-zi-fu-chuan/"/>
    <updated>2013-04-16T15:54:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2013/04/16/pythonchu-li-dai-you-shi-qu-de-de-zi-fu-chuan</id>
    <content type="html"><![CDATA[<p>最近在处理一些微博的数据，其中从服务器返回来的json串最后转换成了python中的字典，
只是可惜时间也被变成了字符串格式，好在python文档足够全且简单，可以使用datetime
中的strptime来解决，尽管如此还是在时区那卡了会</p>

<p>微博返回的时间数据格式如下：</p>

<h5 id="fri-aug-12-140931-0800-2011">“Fri Aug 12 14:09:31 +0800 2011″</h5>

<p>然后我这样处理的</p>

<p><code>
time.strptime('Fri Aug 12 14:09:31 +0800 2011', '%a %b %d %H:%M:%S %z %Y')
</code>
<!--more-->
当然也可以这样，只是试验下而已</p>

<p><code>
dt2 = datetime.strptime('Fri Aug 12 14:09:31 +0800 2011', '%a %b %d %H:%M:%S %Z %Y')
</code></p>

<p>然而却出现了如下的错误：</p>

<p><code>
ValueError: time data 'Fri Aug 12 14:09:31 +0800 2011' does not match format '%a %b %d %H:%M:%S %Z %Y'
</code></p>

<p>查了下<a href="http://stackoverflow.com/questions/10540399/strftime-does-not-return-abbreviated-time-zone">资料</a>
发现这个跟系统有关系，而且这个是bug，（虽然开发者不承认，但是我觉得还有有点关系….虽然它又跟locals有关系。。。识别起来
确实很繁琐）比如现在我是在windows上处理的结果就是</p>

<p><code>
&gt;&gt;&gt; print time.strftime("%a, %d %b %Y %I:%M:%S %p %Z", time.localtime(10.5))
Thu, 01 Jan 1970 08:00:10 AM 中国标准时间
&gt;&gt;&gt; print time.strftime("%a, %d %b %Y %I:%M %p %Z", time.gmtime())
Tue, 16 Apr 2013 08:33 AM 中国标准时间
&gt;&gt;&gt;
</code></p>

<p>和那个+8000格格不入，好吧 反正数据的处理设计不到时区，那么可以这样子做</p>

<p><code>
&gt;&gt;&gt; dt2 = datetime.strptime('Fri Aug 12 14:09:31 +0800 2011', '%a %b %d %H:%M:%S +0800 %Y')
&gt;&gt;&gt; print dt2
2011-08-12 14:09:31
</code></p>

<p>对现在的需求来说,反而更好.</p>

<h3 id="section">参考</h3>

<ol>
  <li>
    <p><a href="http://bugs.python.org/issue6641">issue6641</a></p>
  </li>
  <li>
    <p><a href="http://stackoverflow.com/questions/4788533/python-strftime-gmtime-not-respecting-timezone">python-strftime-gmtime-not-respecting-timezone</a></p>
  </li>
  <li>
    <p><a href="http://stackoverflow.com/questions/10540399/strftime-does-not-return-abbreviated-time-zone">strftime-does-not-return-abbreviated-time-zone</a></p>
  </li>
  <li>
    <p><a href="http://forum.open.weibo.com/read.php?tid=11780">微博使用</a></p>
  </li>
  <li>
    <p><a href="http://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior">strftime-and-strptime-behavior</a></p>
  </li>
  <li>
    <p><a href="http://stackoverflow.com/questions/466345/converting-string-into-datetime">converting-string-into-datetime</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[python中关于变量属性的迷惑]]></title>
    <link href="http://aluenkinglee.com/blog/2013/03/15/puzzles-of-vars-properties-in-python/"/>
    <updated>2013-03-15T17:06:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2013/03/15/puzzles-of-vars-properties-in-python</id>
    <content type="html"><![CDATA[<p>当初使用C++，java的时候，变量的属性（可访问性，scope这类的意思）如public，private，protected，static这类很好理解。</p>

<p>但是Python中默认的成员函数，成员变量都是公开的(public),而且python中没有类似public,private等关键词来修饰成员函数，成员变量。</p>

<!-- more -->

<p>在python中定义私有变量只需要在变量名或函数名前加上 ”__“两个下划线，那么这个函数或变量就会为私有的了。对static这样的很是好奇。</p>

<p>于是便有了这样子的实验。</p>

<p>```python
#!/usr/bin/env python
# -<em>- coding: utf-8 -</em>-
class A:
    value = 0</p>

<p>o1 = A()
o2 = A()</p>

<p>print A,o1,o2
print A.value,o1.value,o2.value</p>

<p>o1.value += 10
print A.value,o1.value,o2.value</p>

<p>A.value += 5
print A.value,o1.value,o2.value</p>

<p>o2.value += 5
print A.value,o1.value,o2.value
```</p>

<p>这是我机器上的测试结果，A没有显示地址??怎么回事，两个实例都有自己的地址:</p>

<p><code>
__main__.A &lt;__main__.A instance at 0x01262AD0&gt; &lt;__main__.A instance at 0x013091C0&gt;
0 0 0
0 10 0
5 10 5
5 10 10
</code></p>

<p>前两行的结果都很好理解，但是第三行，之前o2的值一直没有改变，o1的值改变，在A的值改变之后o2也随之改变了，这个时候….看上去，o2还是在引用A的值，但是在o2自己的值改变之后就不在去引用类的值了。</p>

<h5 id="section">由此可见：</h5>

<ul>
  <li>
    <p>由类派生出来的实例在未操作之前，都是简单的引用类的那些值</p>
  </li>
  <li>
    <p>公共属性的值有点类似于大家C++类中的那种静态变量啊</p>
  </li>
  <li>
    <p>只要实例稍作改变，就不会在引用类了。</p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python中得一些重要的细节]]></title>
    <link href="http://aluenkinglee.com/blog/2013/03/15/some-important-details-in-python-personal/"/>
    <updated>2013-03-15T16:17:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2013/03/15/some-important-details-in-python-personal</id>
    <content type="html"><![CDATA[<p>字符串可以被下表索引，和C一样，第一个字符同样是0。</p>

<p>Python中并没有单独的字符类型，一个字符就是长度为1的字符串。</p>

<p>和C字符串不同的是，python字符串值不能更改。</p>

<!-- more -->

<p><code>python
&gt;&gt;&gt; word = 'string'
&gt;&gt;&gt; word[3]='d'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' object does not support item assignment
</code></p>

<p>关于unicode的一些说明，encode(),unicode()那些往
<a href="http://docs.python.org/2/tutorial/introduction.html#unicode-strings">这里看</a></p>

<p>python中一些iterable types（具体术语不知道怎么称呼）是分成可以<code>immutable</code>和<code>mutable</code>的：</p>

<h5 id="mutable">可更改的（<code>mutable</code>）:</h5>

<ul>
  <li>
    <p>字典型(dictionary)</p>
  </li>
  <li>
    <p>列表型(list)</p>
  </li>
</ul>

<h5 id="mutable-1">不可更改（mutable）：</h5>

<ul>
  <li>
    <p>元组（tuple)</p>
  </li>
  <li>
    <p>数值型（number）</p>
  </li>
  <li>
    <p>字符串(string)</p>
  </li>
</ul>

<p>所有的切片操作都是返回一个新的包含请求元素的list。</p>

<p><code>python
&gt;&gt;&gt; a = ['spam', 'eggs', 100, 1234]
&gt;&gt;&gt; a[:]
['spam', 'eggs', 100, 1234]
</code></p>

<p>pass语句请看<a href="http://docs.python.org/2/reference/simple_stmts.html#pass">这里</a></p>

<p>函数中的变量，函数中得变量赋值操作都是把值存在<code>本地符号表（local symbol table）</code>中，
变量引用时先查看本地符号表，在然后是<code>全局符号表（global symbol table）</code>，
最后才是<code>内置表（table of built-in names）</code>，全局变量得先申明下，在使用</p>

<p><code>python
v= 1
def test_global_vars():
    """ 测试使用global"""
    #global v += 1 #wrong!!
    global v 
    v += 1
    print v
</code></p>

<p>突然想到了python中得变量类型这些东西，以下是实验</p>

<p>```python
def test_global_vars():
    “”” 测试使用global”””
    global v
    v += 1
    print v,hex(id(v))</p>

<p>def foo(n):
    “"”测试实参是怎么回事，by value，value总是个函数引用，不是那个
    对象的值,实参也是跟函数内的变量一样被放入到了本地符号表”””
    n += 1
    print n,hex(id(n))</p>

<p>v= 1
print v,hex(id(v))
test_global_vars()
print v,hex(id(v))
foo(v)
print v,hex(id(v))
v+=1
print v,hex(id(v))
```</p>

<p>这是我机器上的一次run result</p>

<p><code>
1 0x1429168
2 0x142915c
2 0x142915c
3 0x1429150
2 0x142915c
3 0x1429150
</code></p>

<p>会发现v的值一样的时候，id值都是一样的。</p>

<p><code>python
v = 1 			#将名字 v 与内存中值为1的内存绑定在一起。
test_global_vars() 	#这句话之后就是把v 和 内存中为2的地址绑定在一起。所以地址会变。
foo(v) 			#形参n 和 内存中为 3 的地址绑定在一起。实参v还是绑定在 2 的地址。
v += 1 			#v的值改变为3 所以地址就绑定到了 3 在内存中得地方。所以这个时候会发现和上一句的地址一样。
</code></p>

<p>很奇特，但是这个样子会有什么好处?</p>

<ul>
  <li>
    <p>首先python支持函数编程，函数式编程在运算的过程中值肯定是不会变得。
想想我们数学中得变量（怎么可能会出现x = x + 1 ！！）数学上讲不通。
这对函数式编程是个利好消息。（但是这很明显不是函数式编程，应该是这
个特性在lamda演算中很有用，待解决）</p>
  </li>
  <li>
    <p>这个…受C、C++的“毒害”深啊，目前还是转不过来,但是在看列表<code>可变</code>之后
，刹那间觉得列表这玩意像指针那种东西啊</p>
  </li>
</ul>

<p><code>python
dic = {"value":3}
b = dic
print dic,b,hex(id(dic)),hex(id(b))
b["value"] = 5
print dic,b,hex(id(dic)),hex(id(b))
</code></p>

<p>但是你看结果，他们都是绑定到同一块内存的，这种字典的就直接在源地址改了</p>

<p><code>python
{'value': 3} {'value': 3} 0x1823d20 0x1823d20
{'value': 5} {'value': 5} 0x1823d20 0x1823d20
</code>
python就是这么设计的，至于为什么，不知道(待解决)</p>

<p>在说句题外话，你看django那些代码写的，都是使用的tuple之类的。url(省略号)…为什么会这个样子，来看看实验的结果</p>

<p>```python
class A(object):
    “"”docstring for A”””
    x = []
    # self.x = [] #这个是错误的语法，只能在__init__中定义
    def <strong>init</strong>(self, arg):
        #x和self.value有什么区别啊
        #x和self.x有什么区别啊
        super(A, self).<strong>init</strong>()
        self.arg = arg
        self.value = []
        self.value.append(1)
        print “in <strong>init</strong>”
        print “x address :\t\t\t\t”, hex(id(x))
        print “self.x address :\t\t”, hex(id(self.x))</p>

<pre><code>def set_x(self):
    self.x.append(1)
def get_x(self):
    print "in get_x"
    print "x address :\t\t\t\t", hex(id(x))
    print "self.x address :\t\t", hex(id(self.x))
    return self.x
def get_xx(self):#很诡异的存在啊，但这个只是定义的不同啊
    print "in get_xx"
    print "x address :\t\t\t\t", hex(id(x))
    print "self.x address :\t\t", hex(id(self.x))
    return x   

def get_value(self):
    return self.value
</code></pre>

<p>for i in range(3):
    a = A(“oj”)
    a.set_x()
    #print A.<strong>dict</strong>
    print a.get_value()
    print a.get_xx()
    print a.get_x()
```</p>

<p>自己跑下试试，在__init__()内外定义的变量是不一样的，x，self.value类似static，全局共享。而self.x就不是了，在编码的时候一定要注意这种细节。</p>

<p>可能上面那个太复杂了些，那么看看这个。</p>

<p>```python
class b:
    x = []
    def <strong>init</strong>(self):
        self.y=[]
    def set(self):
        self.y.append(1)
        self.x.append(1)
    def get(self):
        return x,self.y,self.x</p>

<p>for i in range(3):
    a = b()
    a.set()
    print a.get(),b.<strong>dict</strong>
```</p>

<p>接下来还是关于函数的:</p>

<p>The default values are evaluated at the point of function definition in the defining scope, so that</p>

<p><code>python
i = 5
def f(arg=i): # 默认的初始值 只 赋值一次 ，其后初始就不会改变了。
    print arg
i = 6
f()           # here will print  5！！ 所以这会为5 只要没传递新的参数
</code></p>

<p>但是当形参是个可变对象 如 :列表，字典或者一些类的实例，这个时候会共享这个可变的对象！！！</p>

<p>虽然元组（Tuples）和列表（list）看起来很相似，但是使用的场景不同的。元组通常是不可变的，
通常包括类型不同的元素，可以通过解包和索引来访问。列表是可变的，通常都是些同一类型的元素迭代访问。</p>

<p>遍历技巧，可能需要下标的时候会用到 <a href="http://docs.python.org/2/tutorial/datastructures.html#looping-techniques">这里</a></p>

<hr />

<p>_xxx      不能用’from module import *’导入</p>

<p><strong>xxx</strong> 系统定义名字</p>

<p>__xxx    类中的私有变量名</p>

<p>以单下划线开头_foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入；</p>

<p>以双下划线开头的__foo代表类的私有成员；以双下划线开头和结尾的__foo__代表python里特殊方法专用的标识，如__init__()代表类的构造函数。</p>

<p>“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；</p>

<p>“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。</p>

<h6 id="python">Python中的继承：</h6>

<p>super可以避免显示的引用Base，这听起来很不错，最起码不用自己去判断使用哪个类的构造方法。
但是最最要的用途还是多继承问题。在python2.7中，得这样解决：super(thisClass,self).<strong>init</strong>() ,python3中变成了这样：super().<strong>init</strong>()</p>

<p>样例：仔细观察，不要忘记那个object！！</p>

<p>```python
class Point(object):
	def <strong>init</strong>(self,x=0,y=0):
		self.x = x;
		self.y = y;</p>

<p>class Circle(Point):
	“"”docstring for Circle”””
	def <strong>init</strong>(self, radius=0,x=0,y=0):
		super(Circle,self).<strong>init</strong>()
		# Point.<strong>init</strong>(self,x,y)
		self.radius = radius;
c= Circle(1,0,0)</p>

<p>class Base(object):
    def <strong>init</strong>(self):
        print “Base created”</p>

<p>class ChildA(Base):
    def <strong>init</strong>(self):
        Base.<strong>init</strong>(self)</p>

<p>class ChildB(Base):
    def <strong>init</strong>(self):
        super(ChildB, self).<strong>init</strong>()</p>

<p>print ChildA(),ChildB()
```</p>

]]></content>
  </entry>
  
</feed>
