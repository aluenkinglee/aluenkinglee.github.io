<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: hamming-weight | 曾经渐行远，未免心戚戚]]></title>
  <link href="http://aluenkinglee.com/blog/categories/hamming-weight/atom.xml" rel="self"/>
  <link href="http://aluenkinglee.com/"/>
  <updated>2014-03-24T21:29:32+08:00</updated>
  <id>http://aluenkinglee.com/</id>
  <author>
    <name><![CDATA[Aluen King Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[计算给定数字中非零的个数]]></title>
    <link href="http://aluenkinglee.com/blog/2014/03/24/ji-suan-gei-ding-shu-zi-zhong-fei-ling-de-ge-shu/"/>
    <updated>2014-03-24T20:19:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/03/24/ji-suan-gei-ding-shu-zi-zhong-fei-ling-de-ge-shu</id>
    <content type="html"><![CDATA[<p>看到一个计算二进制数中非零个数的问题，很有意思。我之前知道有两种版本的，现在又看到了一个版本<code>hamming weight</code></p>

<p>版本一大家肯定都能想的到，就是最最朴素的解法，查看该数字字符串表示中的1的个数。看起来应该
像这个样子。</p>

<p><code>cpp
int popcount_1(size_t x)
{
  char buf[BUFFER_SIZE];
  const char* p = buf;
  int cnt = 0;
  itoa(x, buf, 2); //用二进制的表达式
  while(*(p++)) { if(*p == '1')  ++cnt;}
  return cnt;
}
</code></p>

<p>但是空间复杂度和时间复杂度很不理想。都是$\Omega(n)$。</p>

<p>那么好，看下版本2，这个也很简单容易想到。</p>

<p><code>cpp
int popcount_2(size_t x)
{
  int cnt = 0;
  while(x) {
    if(x%2 == 1)  ++cnt;
    x &gt;&gt; 1;	
  }
  return cnt;
}
</code></p>

<p>此时时间复杂度就降为$\Omega(log_{2}x)$。空间复杂度为$\Omega(1)$.</p>

<p>还有一种，这个编程之美上讲的。但是这个情况下是有一些条件限制的。
最好是数字的二进制表示大部分是0，这样计算的次数少，不然运算量也强不到哪去。
对于我这种对位运算不感冒的表示我能看懂，真心想不到…</p>

<p><code>cpp
int popcount_3(size_t x)
{
  int cnt;
  for(cnt =0; x; ++cnt)
    x &amp;= x-1;
  return cnt;
}
</code></p>

<p>时间复杂度为$\Omega(cnt)$,所以运算还是挺快的。</p>

<p>但是看了<a href="http://en.wikipedia.org/wiki/Hamming_weight">hamming weight</a>之后觉得更神奇了。还是那句话，真心想不到，
不过看解释还是很明白的。<code>hamming weight</code>计算的是字符串中，非字符0的个数。</p>

<p>```cpp
//types and constants used in the functions below</p>

<p>const uint64_t m1  = 0x5555555555555555; //binary:  1 zeros,  1 ones …
const uint64_t m2  = 0x3333333333333333; //binary:  2 zeros,  2 ones …
const uint64_t m4  = 0x0f0f0f0f0f0f0f0f; //binary:  4 zeros,  4 ones …
const uint64_t m8  = 0x00ff00ff00ff00ff; //binary:  8 zeros,  8 ones …
const uint64_t m16 = 0x0000ffff0000ffff; //binary: 16 zeros, 16 ones …
const uint64_t m32 = 0x00000000ffffffff; //binary: 32 zeros, 32 ones
const uint64_t hff = 0xffffffffffffffff; //binary: all ones
const uint64_t h01 = 0x0101010101010101; //the sum of 256 to the power of 0,1,2,3…</p>

<p>//This is a naive implementation, shown for comparison,
//and to help in understanding the better functions.
//It uses 24 arithmetic operations (shift, add, and).
int popcount_1(uint64_t x) {
giving # of 1s in each 2-bit piece of A
    //计算模式1下2-bit 形式中1的个数
    x = (x &amp; m1 ) + ((x »  1) &amp; m1 ); //put count of each  2 bits into those  2 bits 
    //计算模式2下4-bit 形式中1的个数
    x = (x &amp; m2 ) + ((x »  2) &amp; m2 ); //put count of each  4 bits into those  4 bits 
    //计算模式3下8-bit 形式中1的个数
    x = (x &amp; m4 ) + ((x »  4) &amp; m4 ); //put count of each  8 bits into those  8 bits 
    //计算模式4下16-bit 形式中1的个数
    x = (x &amp; m8 ) + ((x »  8) &amp; m8 ); //put count of each 16 bits into those 16 bits 
    //计算模式5下32-bit 形式中1的个数
    x = (x &amp; m16) + ((x » 16) &amp; m16); //put count of each 32 bits into those 32 bits 
    //计算模式6下64-bit 形式中1的个数
    x = (x &amp; m32) + ((x » 32) &amp; m32); //put count of each 64 bits into those 64 bits 
    return x;
}
```</p>

<p>剩下的那个没有看懂，这个在cnt个数较多的时候用起来还是比较不错的。</p>

<h2 id="section">参考</h2>

<ol>
  <li><a href="http://en.wikipedia.org/wiki/Hamming_weight">hamming weight</a></li>
</ol>
]]></content>
  </entry>
  
</feed>
