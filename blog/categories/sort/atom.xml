<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sort | 曾经渐行远，未免心戚戚]]></title>
  <link href="http://aluenkinglee.com/blog/categories/sort/atom.xml" rel="self"/>
  <link href="http://aluenkinglee.com/"/>
  <updated>2014-09-02T03:59:52+08:00</updated>
  <id>http://aluenkinglee.com/</id>
  <author>
    <name><![CDATA[Aluen King Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[链表排序]]></title>
    <link href="http://aluenkinglee.com/blog/2014/05/14/sort-list/"/>
    <updated>2014-05-14T13:51:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/05/14/sort-list</id>
    <content type="html"><![CDATA[<p>链表不想数组那样是连续的即像数组那样随机访问，只能从前往后遍历。所以排序的方法只能是像插入排序，选择排序，和归并排序。</p>

<p>下面就先说归并排序。</p>

<!-- more -->

<p>简单的数据结构</p>

<p><code>java
public static class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
        }
}
</code></p>

<p>思想很简单，就是找到链表的中点，然后左右递归排序，最后合并。
详情还是看代码：</p>

<p>```java</p>

<pre><code>/**
 * @param head
 * @return 链表中点
 */
public ListNode middle(ListNode head) {
    if (head == null || head.next == null)
        return head;
    ListNode pre = head;
    ListNode cur = head.next;
    while (cur != null &amp;&amp; cur.next != null) {
        pre = pre.next;
        cur = cur.next;
        if (cur != null) {
            cur = cur.next;
        }
    }
    return pre;
}

public ListNode merge(ListNode leftHead, ListNode rightHead) {
    // 头部节点，本身没有用处，只是为了让代码更简便
    ListNode head = new ListNode(0);
    ListNode cur = head;
    while (leftHead != null &amp;&amp; rightHead != null) {
        if (leftHead.val &lt; rightHead.val) {
            cur.next = leftHead;
            leftHead = leftHead.next;
        } else {
            cur.next = rightHead;
            rightHead = rightHead.next;
        }
        cur = cur.next;
    }

    if (leftHead != null) {
        cur.next = leftHead;
    }
    if (rightHead != null) {
        cur.next = rightHead;
    }
    return head.next;
}

public ListNode sortList(ListNode head) {
    //单个节点直接返回
    if (head != null &amp;&amp; head.next != null) {
        ListNode mid = middle(head);
        ListNode after = mid.next;
        mid.next = null;
        head = sortList(head);
        after = sortList(after);
        head = merge(head, after);
    }
    return head;
} ```
</code></pre>

<p>测试样例：边界值
2 1
1 
2 -1 1</p>
]]></content>
  </entry>
  
</feed>
