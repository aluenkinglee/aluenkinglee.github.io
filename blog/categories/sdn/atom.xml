<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SDN | 曾经渐行远，未免心戚戚]]></title>
  <link href="http://aluenkinglee.com/blog/categories/sdn/atom.xml" rel="self"/>
  <link href="http://aluenkinglee.com/"/>
  <updated>2014-09-02T03:59:52+08:00</updated>
  <id>http://aluenkinglee.com/</id>
  <author>
    <name><![CDATA[Aluen King Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[install nox on debian-bug fixed]]></title>
    <link href="http://aluenkinglee.com/blog/2013/11/13/install-nox-on-debian-bug-fixed/"/>
    <updated>2013-11-13T22:44:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2013/11/13/install-nox-on-debian-bug-fixed</id>
    <content type="html"><![CDATA[<p>首先需要声明的一点是，到目前（2013/11）Nox在所有SDN控制器中不是最火的（相比Pox，floodlight），但是作为最先开发的一个SDN而言，还是有研究意义的。</p>

<!--more-->

<h5 id="section">安装提示</h5>

<p><code>
cd /etc/apt/sources.list.d/
sudo wget http://openflowswitch.org/downloads/debian/nox.list
sudo apt-get update
sudo apt-get install nox-dependencies
sudo apt-get install libtbb-dev
sudo apt-get install libboost-serialization-dev libboost-all-dev
</code></p>

<p>然后在你想放置Nox源码的地方做如下操作：</p>

<p><code>
git clone git://github.com/noxrepo/nox
cd nox
./boot.sh
mkdir build
cd build
../configure
make -j 5
make install
</code></p>

<p>很不幸，遇到了如下的错误：</p>

<p><code>
../../src/builtin/component.cc:414:1: required from here
/usr/include/boost/property_tree/detail/json_parser_read.hpp:105:17: error:
no matching function for call to ‘boost::property_tree::basic_ptree
std::basic_string&lt;char, std::basic_string &gt;::push_back(std::pair
std::basic_string&lt;char, std::basic_string &gt;)’
/usr/include/boost/property_tree/detail/json_parser_read.hpp:105:17: note:
candidate is:
In file included from /usr/include/boost/property_tree/ptree.hpp:516:0,
from ../../src/include/component.hh:35,
from ../../src/builtin/component.cc:18:
/usr/include/boost/property_tree/detail/ptree_implementation.hpp:362:9:
note: boost::property_tree::basic_ptree::iterator
boost::property_tree::basic_ptree::push_back(const value_type&amp;) [with Key =
std::basic_string; Data = std::basic_string; KeyCompare = std::less
std::basic_string&lt;char &gt;; boost::property_tree::basic_ptree::value_type =
std::pair, boost::property_tree::basic_ptreestd::basic_string&lt;char,
std::basic_string &gt; &gt;]
/usr/include/boost/property_tree/detail/ptree_implementation.hpp:362:9:
note: no known conversion for argument 1 from ‘std::pair
std::basic_string&lt;char, std::basic_string &gt;’ to ‘const value_type&amp; {aka
const std::pair, boost::property_tree::basic_ptreestd::basic_string&lt;char,
std::basic_string &gt; &gt;&amp;}’
make[4]: *** [nox_core-component.o] Error 1
</code></p>

<p>这个错误来源于nox依赖的boost库版本（1.49）的错误.注意错误原因是：</p>

<p><code>
/usr/include/boost/property_tree/detail/json_parser_read.hpp:105
error:
no matching function for call to ‘boost::property_tree::basic_ptree
std::basic_string&lt;char, std::basic_string &gt;::push_back(std::pair
std::basic_string&lt;char, std::basic_string &gt;)’
</code></p>

<p>同样的问题点击<a href="http://lists.noxrepo.org/pipermail/nox-dev-noxrepo.org/2013-February/000668.html" title="[nox-dev] Nox build fails">这里</a></p>

<p>解决方法：<code>/usr/include/boost/property_tree/detail/json_parser_read.hpp</code>找到这个文件。定位到<code>105行，</code></p>

<p><code>
c.stack.back()-&gt;push_back(std::make_pair(c.name, Str(b, e)));
</code></p>

<p>换成</p>

<p><code>
c.stack.back()-&gt;push_back(std::make_pair(c.name, Ptree(Str(b, e))));
</code></p>

<p>重新make&amp;&amp; make install 即可。</p>

<h5 id="reference">Reference</h5>

<ol>
  <li>
    <p><a href="https://svn.boost.org/trac/boost/ticket/6785">read_json does not compile on GCC 4.7.0 with std=c++11</a></p>
  </li>
  <li>
    <p><a href="http://lists.noxrepo.org/pipermail/nox-dev-noxrepo.org/2013-February/000668.html">nox-dev Nox build fails</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtualbox网络环境和登录]]></title>
    <link href="http://aluenkinglee.com/blog/2013/10/20/virtualbox-network-environment-and-login/"/>
    <updated>2013-10-20T22:46:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2013/10/20/virtualbox-network-environment-and-login</id>
    <content type="html"><![CDATA[<p>最近由于实验室需要研究SDN的一些东西，再此先来搭配下环境。
对于虚拟机的一些选择，可以看这里:
<a href="http://mininet.org/vm-setup-notes/">vm-setup-notes</a> 
我这里的环境是:</p>

<p><code>os:            debian 7(wheezy) 64bit</code></p>

<p><code>xwindows:      kde</code></p>

<p><code>VM：           virtualbox</code></p>

<p><code>controller:    pox</code></p>

<!--more-->

<p>按照上述的网址，可以比较容易的搭配出来需要的环境，下面就说以下之后遇到的问题。</p>

<ul>
  <li>virtualbox的鼠标独占问题，只是提示太不明明显了！对于那个right ctrl的提示我郁闷了好一会，我以为是鼠标右键+ctrl…其实是右边的ctrl键。对于这个键的设定，你可以从“管理”&gt;“全局设定”&gt;”热键”来设置你喜欢的按键..我就吐槽这么一句，之前vmware对此的说明很明了！</li>
  <li>Using Host-only adapter to SSH guest from host.</li>
</ul>

<h3 id="nat">NAT模式</h3>
<p>特点：
1. 如果主机可以上网，虚拟机可以上网
2. 虚拟机之间不能ping通
3. 虚拟机可以ping通主机（此时ping虚拟机的网关，即是ping主机）
4. 主机不能ping通虚拟机</p>

<p>但是这个情况下是不能满足我的使用条件…我需要在host登录到guest中，so pass</p>

<h3 id="section">桥接模式</h3>
<p>特点：
1. 如果主机可以上网，虚拟机可以上网
2. 虚拟机之间可以ping通
3. 虚拟机可以ping通主机
4. 主机可以ping通虚拟机 (以上各点基于一个前提：主机可以上网)
5. 如果主机不可以上网，所有1-4特点均无</p>

<p>这个挺好，觉得可以满足我的要求但是，发现它的IP地址要求是自动非配的，我们实验室的IP是校园内网固定IP…</p>

<h3 id="host-only-adapter">Host-only Adapter模式</h3>

<p>特点：</p>

<ol>
  <li>虚拟机<code>不</code>可以上网</li>
  <li>虚拟机之间可以ping通</li>
  <li>虚拟机可以ping通主机（注意虚拟机与主机通信是通过主机的名为VirtualBox Host-Only Network的网卡，因此ip
是该网卡ip <code>192.168.56.1</code>，而不是你现在正在上网所用的ip）</li>
  <li>主机可以ping通虚拟机</li>
</ol>

<p>应用场景：
需要搭建一个模拟局域网，所有机器可以互访。（颇不得以选这个的..）</p>

<p>ip样式：<code>netstat -rn</code>查看路由表
ip 与本机VirtualBox Host-Only Network的网卡ip在同一网段内（默认192.168.56.*）
网关 本机VirtualBox Host-Only Network的网卡ip（默认192.168.56.1）</p>

<h3 id="section-1">登录虚拟机</h3>
<p>登录虚拟机，首先开开virtualbox的虚拟机</p>

<p><code>
mininet-vm login: mininet
Password: mininet
</code></p>

<p>接下来查看我们的vm地址：（在guest里面操作）</p>

<p><code>
sudo ifconfig
</code>
例如我这里的ip地址是<code>192.168.56.101</code>,然后就使用我们可爱的SSH</p>

<p><code>
ssh -Y mininet@192.168.56.101
</code>
输入密码就可以了</p>

<p>当然上面的不好看，做下别名好了。（在我们host里面操作）</p>

<p><code>
sudo nano /etc/hosts
192.168.56.101 mininet-vm
</code></p>

<p>保存即可，这样子就可以使用</p>

<p><code>
ssh -Y mininet@mininet-vm
</code></p>

<p>接下来就可以去玩下面的实验了^^</p>

<blockquote>
  <p>参考文档:</p>
</blockquote>

<blockquote>
  <p><a href="http://blog.csdn.net/yxc135/article/details/8458939">VirtualBox虚拟机网络环境解析</a></p>
</blockquote>

<blockquote>
  <p><a href="http://www.live-in.org/archives/832.html">ssh命令用于远程登录上Linux主机</a></p>
</blockquote>

<blockquote>
  <p><a href="http://mininet.org/vm-setup-notes/">SSH into VM</a></p>
</blockquote>
]]></content>
  </entry>
  
</feed>
