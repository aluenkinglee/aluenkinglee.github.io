<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 动态规划 | 曾经渐行远，未免心戚戚]]></title>
  <link href="http://aluenkinglee.com/blog/categories/dong-tai-gui-hua/atom.xml" rel="self"/>
  <link href="http://aluenkinglee.com/"/>
  <updated>2014-07-14T14:08:43+08:00</updated>
  <id>http://aluenkinglee.com/</id>
  <author>
    <name><![CDATA[Aluen King Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我对KMP算法的理解]]></title>
    <link href="http://aluenkinglee.com/blog/2014/05/19/my-understanding-about-kmp/"/>
    <updated>2014-05-19T22:56:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/05/19/my-understanding-about-kmp</id>
    <content type="html"><![CDATA[<p>和朴素的字符串匹配算法相比，KMP加快匹配的关键在于当某个位置不匹配了，不在模版不再是向右滑动一个位置，而是跟匹配处相关的一个值。这样，在字符串的匹配时间就是和搜索串长度相关的一个值<script type="math/tex">O(n)</script>。</p>

<p>至于相关的资料，参阅了<a href="http://blog.csdn.net/v_july_v/article/details/7041827">六之再续：KMP算法之总结篇（12.09修订，必懂KMP</a>，只是这个个人感觉有点凌乱。</p>

<p>定义要搜索的字符串模式是<script type="math/tex">P</script>,搜索的源是文本<script type="math/tex">T</script>.那让我们看看next数组怎么诞生的。</p>

<h4 id="section">局部匹配表</h4>

<p>理解KMP算法的关键就是<strong>局部匹配表</strong>,或者形象的称作为<strong>next数组</strong>，
<a href="http://book.douban.com/subject/1885170/">算法导论</a>p571页详细的描述了推导的过程，并给出了证明。但是仍然还是晦涩难懂的。</p>

<p>对于这个推论：设<script type="math/tex">P</script>是长度为<script type="math/tex">m</script>的模式，next是P的前缀函数，对于<script type="math/tex">q=2,3,...,m</script></p>

<script type="math/tex; mode=display">% &lt;![CDATA[

next\left[ q \right] =\begin{Bmatrix} 0 & \quad if\quad { E }_{ q }\quad =\quad \phi  \\ 1+max\{ k\in { E }_{ q-1 }\}  & \quad if\quad { E }_{ q-1 }\quad =\phi  \end{Bmatrix}
 %]]&gt;</script>

<p>直观来说就是才用动规的方法，求<script type="math/tex">next\left[ q \right]</script>的最长前缀的长度。</p>

<p>那么好吧，再来个直观点的手写算法吧╮(╯▽╰)╭。</p>

<p>就以书上的例子为准，见下图。</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-05-19-my-understanding-about-kmp/1.png?raw=true" alt="a)" title="a)" /></p>

<p>前q=5个字符匹配，标记为绿色。</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-05-19-my-understanding-about-kmp/2.png?raw=true" alt="b)" title="b)" /></p>

<p>很明显，s+1的位置是无效的，但是s+2的位置很有可能是有效的，所以，可以直接向右移动2个位置。</p>

<p>推导中的使用的有用信息可以通过模式自身的比较来预处理计算得到。在这里，可以发现P的最长前缀同时也是<script type="math/tex">P_5</script>的一个真后缀<script type="math/tex">P_3</script>.这些信息可以预先急死俺，用数组next来表示，next[5]=3. 一般化的公式为，在位移s处有q个字符成功匹配，囊而下个有可能有效的位移是<script type="math/tex">s=s-(q-next[q])</script>.</p>

<p>上面提到了<strong>真后缀</strong>,让我们给出定义来。</p>

<p><strong>真前缀</strong>： 字符串中去除1个至多个尾部字符的字符串集合。比如aabac的真前缀为a,aa,aab,aaba.</p>

<p><strong>真后缀</strong>： 字符串中去除1个至多个头部字符的字符串集合。比如aabac的真后缀为c,ac,bac,abac.</p>

<p>好了 ，有了上面的定义，我们就可以简单，最重要的是明白计算next值了：<code>某个位置的next值为，到此位置的字符串产生的真前缀和真后缀</code><strong>并集</strong><code>中的最长元素的长度</code>。</p>

<p>就比如上面的那个例子，模式串为”ababaca”</p>

<p>```text
“a”的真前缀和真后缀都为空集，next[0]=0;</p>

<p>“ab”的真前缀为[b],真后缀为[a], next[1]=0;</p>

<p>“aba”的真前缀为[a,ab],真后缀为[a,ba],next[2]=1;</p>

<p>“abab”的真前缀为[a,ab,aba],真后缀为[b,ab,bab],next[3]=2;</p>

<p>“ababa”的真前缀为[a,ab,aba,abab],真后缀为[baba,aba,ba,a],next[4]=3;</p>

<p>“ababac”的真前缀为[a,ab,aba,abab,ababa],真后缀为[babac,abac,bac,ac,c],next[5]=0;</p>

<p>“ababaca”的真前缀为[a,ab,aba,abab,ababa,ababac],真后缀为[babaca,abaca,baca,aca,ca,a],next[5]=1;
```</p>

<h4 id="section-1">如何使用</h4>

<p>见上面的例子吧，很好理解不是。</p>

<p>对了一下是代码。</p>

<p><code>cpp
void compute_prefix(const char* p, int *next)
{
    next[0]=0;
    int len = strlen(p);
    int k =0,q;
    for(q=1; q &lt; len; q++)
    {
        ///前q个字符中，前缀字符串集和后缀字符串集中最长的交集元素的长度
        while( (k &gt; 0) &amp;&amp; (p[k] != p[q]) )
            k = next[k-1];
        /// 请看前面的那个状态转移函数的公式
        if( p[k] == p[q] )
            k=k+1;
        next[q] = k;
    }
}
</code></p>

<p><code>cpp
void kmp_match(const char* T, const char* P)
{
    bool flag=false;
    int n=strlen(T);
    int m=strlen(P);
    int *next = new int[m];
    compute_prefix(P, next);
    int q=0;
    for (int i=0; i&lt;n; i++)
    {
        while(q&gt;0 &amp;&amp; P[q]!=T[i])
            q=next[q-1];
        if(P[q]==T[i])
            q=q+1;
        if(q==m)
        {
            flag=true;
            cout&lt;&lt;"math occurs with "&lt;&lt;i-m+1&lt;&lt;endl;
            q=next[q-1];
        }
    }
    if(flag==false)
        cout&lt;&lt;"there is no math!"&lt;&lt;endl;
}
</code></p>

<h4 id="section-2">总结</h4>

<p>相对于朴素的匹配算法，这里并不是在匹配失败后直接无脑的外后移一位就可以了，而是利用了模式串本身的信息，<strong>位移的距离=已经匹配的长度-该位置next值</strong>。</p>

<p>希望对你有用。当然要是觉得有问题直接留言好了，一起学吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dynamic programming]]></title>
    <link href="http://aluenkinglee.com/blog/2014/04/29/dynamic-programming/"/>
    <updated>2014-04-29T19:34:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/04/29/dynamic-programming</id>
    <content type="html"><![CDATA[<p>好几年了，没有特意去做与ACM相关的算法题了，时至今日，也确实忘得差不多了，不过，现在也到了该拾起来的时候了。</p>

<h5 id="section">动态规划</h5>
<!--more -->

<p>动态规划（Dynamic Programming）是用来解决最优化问题的最常用手段,说起定义，网上浩瀚如烟，有很多类型，比如：</p>

<ul>
  <li>
    <p>背包问题：0-1背包，完全背包，硬币问题，装箱子问题等。</p>
  </li>
  <li>
    <p>最短路径问题：网络流等。</p>
  </li>
  <li>
    <p>树形动规：最优查找树。</p>
  </li>
</ul>

<p>等等等等，严格的划分问题类型没有意义，关键是分析问题的本质：阶段，状态，状态转移，全局最优。</p>

<h5 id="section-1">一些术语</h5>

<p>首先，先介绍下相关的概念，在结合具体的，例子加深感性和理性上的认识。</p>

<p>动态规划问题的一个通用特点是具备<code>最优子结构</code>和<code>重叠子问题</code>。当前子问题的解将由上一次子问题的解推出。每一个问题对应一个它的<strong>状态</strong>。<code>重叠子问题</code>的意思，某些问题的计算是有重叠的，若该计算结果记录下来，之后其他子问题遇到重叠的直接查表就可以了，避免重复计算。最优子结构则是我们的全局问题可以分解，按照<strong>阶段</strong>来分解。从而规约到最简的问题。说到这，是不是想到了分治法？，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次（把它们记录下来嘛！）。而且另外一个思想是，动规有明显的阶段的概念，而分治只是把问题分成不重复的规模较小的没有阶段概念的小问题。</p>

<p><strong>基本结构</strong></p>

<p>多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法。</p>

<p><strong>什么是动态规划，我们要如何描述它?</strong></p>

<p>先来看下形式化的描述的吧，在结合例子描述它。</p>

<script type="math/tex; mode=display">
f\left( S \right) =\underset { d\in D\left( S \right)  }{ opt } \left\{ cos\left( d\vert S \right) \quad \circ \quad f\left( T\left( d|S \right)  \right)  \right\} 
</script>

<p>其中，<code>S</code>是代指<code>state</code>，就是状态空间的一个state，动态规划解决的问题是按照状态和该状态可以选择的决策来解决问题的。确切的来说，<code>S</code>代表的就是从开始到当前决策的问题状态；</p>

<p><code>d</code>代指<code>decision</code>，是一个从<code>S</code>状态所决定的决策空间中<script type="math/tex">D\left( S \right) </script>做出的决策，不同状态决定的决策空间有可能不同。举例说明，对于硬币问题来讲，假设每个硬币的个数都是无限的，那么对于任何一个状态（目前手里有多少钱），接下来做的决策个数都是一样的，都是从固定的那几枚硬币中挑选；对于不可重复选择的问题，比如拿球，有红黑黄3个球，每个球的权值不同，求一个选球次序使之最优，这下好了，每个阶段的决策空间都是不同的，对于状态1，有红，黑，黄三种状态，接下来，就只能选剩下的球里面的了。所以决策空间会因问题而变化的。还有TSP旅行者问题，在每个节点所对应的状态时从起点到当前状态的最短距离，接下来的选择，得看该节点（状态）的出度是谁了。<strong>所以说，决策依赖当前的状态</strong>。</p>

<p><script type="math/tex">D\left( S \right) </script>是决策空间(decision space)，代表从当前状态转到另一个状态时，或者从另一个状态转到当前状态可以选择的决策<code>d</code>的结合。（之所以使用或者是说了两种考虑的方式）</p>

<p><code>f</code>是指目标函数(target function)，一个关于状态的函数，往往代表从初始状态到达状态<code>S</code>所做的所有决策中的最优利益（不是最大就是最小）。</p>

<p><script type="math/tex">cos\left( d\vert S \right) </script>可以叫做成本函数(cost function)，很好理解，就是在状态<code>S</code>下，做出选择<code>d</code>的成本，成本函数和目标函数不同，因为它不需要依赖上下文条件，只需一步计算就可以搞定。</p>

<p><script type="math/tex">cos\left( d\vert S \right) </script>代表的是转移函数(transfer function)，就是指从S做一个决策到达另外一个状态<script type="math/tex">S'</script>.</p>

<p><script type="math/tex">\circ</script>是一个二元操作符，多数是加法或者乘法或者是最大值要不就是最小值。</p>

<p>除此之外，还需要边界条件。</p>

<p>最后来看个最简单的例子。</p>

<h5 id="section-2">例子</h5>

<p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？有多少种兑换方法？</p>

<p>思路：这个比较简单，状态就是硬币的价值，有多少钱，决策空间是固定的<script type="math/tex">D(S)={1,3,5}</script></p>

<p>用<script type="math/tex">f(i)</script>代表凑够i元，得用最少多少硬币。成本函数也是固定的，为1。</p>

<script type="math/tex; mode=display">
f(i)=\underset { d\in D\left( {1,3,5} \right)  }{min}{1+f(i-d)},i!=0
</script>

<p>当然了<script type="math/tex">i==0</script>时，f(0)=0.</p>

<p><code>text
f(11)=min{1+f(11-1),1+f(11-3),1+f(11-5)};
f(10)=min{1+f(10-1),1+f(10-3),1+f(10-5)};
f(9)=min{1+f(9-1),1+f(9-3),1+f(9-5)};
f(8)=min{1+f(8-1),1+f(8-3),1+f(8-5)};
f(7)=min{1+f(7-1),1+f(7-3),1+f(7-5)};
f(6)=min{1+f(6-1),1+f(6-3),1+f(6-5)};
f(5)=min{1+f(5-1),1+f(5-3),1+f(5-5)};
f(4)=min{1+f(4-1),1+f(4-3) )};
f(3)=min{1+f(3-1),1+f(3-3) )};
f(2)=min{1+f(2-1)};
f(1)=min{1+f(1-1)};
f(0)已知=0；
</code></p>

<p>所以：</p>

<p><code>text
f(1)=min{1+f(1-1)}=1；
f(2)=min{1+f(2-1)}=2；
f(3)=min{1+f(3-1),1+f(3-3) )}=min{3,1}=1;
f(4)=min{1+f(4-1),1+f(4-3) )}=min{2,2}=2;
f(5)=min{1+f(5-1),1+f(5-3),1+f(5-5)}=min{3,3,1}=1;
f(6)=min{1+f(6-1),1+f(6-3),1+f(6-5)}=min{2,2,2}=2;
f(7)=min{1+f(7-1),1+f(7-3),1+f(7-5)}=min{3,3,3}=3;
f(8)=min{1+f(8-1),1+f(8-3),1+f(8-5)}=min{4,2,2}=2;
f(9)=min{1+f(9-1),1+f(9-3),1+f(9-5)}=min{3,3,3}=3;
f(10)=min{1+f(10-1),1+f(10-3),1+f(10-5)}=min{4,4,2}=2;
f(11)=min{1+f(11-1),1+f(11-3),1+f(11-5)}=min{3,3,3}=3;
</code></p>

<p>从我们的计算过程来看，求解既可以从前往后也可以从后往前。</p>

]]></content>
  </entry>
  
</feed>
