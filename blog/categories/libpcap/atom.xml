<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: libpcap | 曾经渐行远，未免心戚戚]]></title>
  <link href="http://aluenkinglee.com/blog/categories/libpcap/atom.xml" rel="self"/>
  <link href="http://aluenkinglee.com/"/>
  <updated>2014-07-14T14:08:43+08:00</updated>
  <id>http://aluenkinglee.com/</id>
  <author>
    <name><![CDATA[Aluen King Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[“奇异”的内存覆盖]]></title>
    <link href="http://aluenkinglee.com/blog/2014/03/04/qi-yi-de-nei-cun-fu-gai/"/>
    <updated>2014-03-04T22:01:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/03/04/qi-yi-de-nei-cun-fu-gai</id>
    <content type="html"><![CDATA[<p>犯了一个愚蠢的问题，让我碰到了这么个内容错误的bug</p>

<!--more-->

<p><code>bash
*** glibc detected *** ./main: free(): invalid next size (fast): 0x0000000001dd8590 ***
======= Backtrace: =========
/lib/x86_64-linux-gnu/libc.so.6(+0x76d76)[0x7fd77419fd76]
/lib/x86_64-linux-gnu/libc.so.6(cfree+0x6c)[0x7fd7741a4aac]
/usr/lib/x86_64-linux-gnu/libpcap.so.0.8(+0x1b470)[0x7fd774e2e470]
/usr/lib/x86_64-linux-gnu/libpcap.so.0.8(pcap_loop+0x2f)[0x7fd774e1fecf]
./main[0x401869]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xfd)[0x7fd774147ead]
./main[0x401001]
======= Memory map: ========
00400000-00402000 r-xp 00000000 08:08 1982169                            /home/kinglee/github/stuff/cplusplus/traffic_parser/main
00602000-00603000 rw-p 00002000 08:08 1982169                            /home/kinglee/github/stuff/cplusplus/traffic_parser/main
01dc8000-01de9000 rw-p 00000000 00:00 0                                  [heap]
7fd770000000-7fd770021000 rw-p 00000000 00:00 0 
7fd770021000-7fd774000000 ---p 00000000 00:00 0 
7fd774129000-7fd7742a9000 r-xp 00000000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so
7fd7742a9000-7fd7744a9000 ---p 00180000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so
7fd7744a9000-7fd7744ad000 r--p 00180000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so
7fd7744ad000-7fd7744ae000 rw-p 00184000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so
7fd7744ae000-7fd7744b3000 rw-p 00000000 00:00 0 
7fd7744b3000-7fd7744c8000 r-xp 00000000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1
7fd7744c8000-7fd7746c8000 ---p 00015000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1
7fd7746c8000-7fd7746c9000 rw-p 00015000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1
7fd7746c9000-7fd77474a000 r-xp 00000000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so
7fd77474a000-7fd774949000 ---p 00081000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so
7fd774949000-7fd77494a000 r--p 00080000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so
7fd77494a000-7fd77494b000 rw-p 00081000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so
7fd77494b000-7fd774a33000 r-xp 00000000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17
7fd774a33000-7fd774c33000 ---p 000e8000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17
7fd774c33000-7fd774c3b000 r--p 000e8000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17
7fd774c3b000-7fd774c3d000 rw-p 000f0000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17
7fd774c3d000-7fd774c52000 rw-p 00000000 00:00 0 
7fd774c52000-7fd774c72000 r-xp 00000000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so
7fd774e0e000-7fd774e13000 rw-p 00000000 00:00 0 
7fd774e13000-7fd774e4b000 r-xp 00000000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0
7fd774e4b000-7fd774e4d000 r--p 00037000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0
7fd774e4d000-7fd774e4e000 rw-p 00039000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0
7fd774e4e000-7fd774e4f000 rw-p 00000000 00:00 0 
7fd774e6d000-7fd774e71000 rw-p 00000000 00:00 0 
7fd774e71000-7fd774e72000 r--p 0001f000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so
7fd774e72000-7fd774e73000 rw-p 00020000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so
7fd774e73000-7fd774e74000 rw-p 00000000 00:00 0 
7fff1591a000-7fff1593b000 rw-p 00000000 00:00 0                          [stack]
7fff159ff000-7fff15a00000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
已放弃
</code> </p>

<p>对于这个问题，当时表示怎么会出现内存错误？我指针根本没有指错啊！那块内存也没有回收阿！！原来的程序比较大，所以我就抽象写了个简单的，慢慢找。</p>

<p>```c++
#include <string>
#include <iostream>
#include <algorithm>
#include <vector /></algorithm></iostream></string></p>

<p>using namespace std;
typedef class packet
{
    private:
    int len;
    char* data;
    public:
    packet(int l,char * p)
    {
	//注意这里，开始我写成了这样，一开始写顺了…
	//我本意是想申请一个长度为l的连续内存区域。
	//结果本意成为了申请了一个单位的内存，并给它赋值！！
        data=new char(l);
        //应该写成这样
        //data=new char[l];
        copy(p,p+l,data);
        len = l;
    }</p>

<pre><code>packet(const packet&amp; p)  
{
    this-&gt;len=p.len;
    data=new char[len];
    copy(p.data, p.data+len,data);
}

packet&amp; operator=(const packet&amp; p)
{
    this-&gt;len = p.len;
    this-&gt;data = new char[this-&gt;len];
    copy(p.data, p.data+len,this-&gt;data);
    return *this;
} 

~packet(){delete[] data;}
char* get_data(){return data;}
</code></pre>

<p>}packet;</p>

<p>int main()
{
    vector<packet> stream;
    char *t = "hello world.\n";
    packet p(5,t);
    cout &lt;&lt; p.get_data( )&lt;&lt; endl;
    stream.push_back(p);
    cout &lt;&lt; stream[0].get_data() &lt;&lt;endl;
    return 0;
}
```</packet></p>

<p>编译运行就会出错。</p>

<p><code>
g++ test.cc -o main 
</code></p>

<p>所以，上述的语句是没有申请够足够的内存(只申请了一个，却按照那个长度来copy！！当然会出现数据覆盖的错误，这个属于语言错误)，所以会造成之后的内存覆盖，导致出错。有意思的是在windows平台上，我试过，是不会提示你出错的。
不过确实可以看到运行过程中不合理的地方。比如数据被覆盖了overlapping!（实验平台debian 7 ，g++ (Debian 4.7.2-5) 4.7.2
windows是win7 + mingw）</p>

<p><code>
*** glibc detected *** ./main: double free or corruption (fasttop): 0x0000000000e55010 ***
</code></p>

<p>另外一点，在实际使用过程中，还是尽量不要混合使用malloc 和delete/delete[]</p>

<ul>
  <li>
    <p>使用malloc分配的内存尽量使用free释放掉</p>
  </li>
  <li>
    <p>使用new分配的内存，看情况，若是对象类型本身就是数组类型，使用delete[],否则使用delete释放掉内存</p>
  </li>
  <li>
    <p>使用new[]分配内存的，必须使用delete[] 来释放掉内存。否则只是释放掉了内存区域的第一个从而造成内存泄漏。</p>
  </li>
</ul>

<blockquote>
  <blockquote>
    <p>参考</p>
  </blockquote>
</blockquote>

<ul>
  <li>
    <p><a href="http://stackoverflow.com/questions/18389313/glibc-detected-main-free-invalid-next-size-fast">’** glibc detected *** ./main: free(): invalid next size (fast):’</a></p>
  </li>
  <li>
    <p><a href="http://www.cplusplus.com/reference/cstring/memcpy/?kw=memcpy">‘好好使用memcpy’</a></p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解TCP中的序列号和确认号]]></title>
    <link href="http://aluenkinglee.com/blog/2014/02/26/li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/"/>
    <updated>2014-02-26T22:34:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/02/26/li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao</id>
    <content type="html"><![CDATA[<p>之所以写这么一篇文章是因为被wireshark的序列号搞晕了，我不知道你们是否这样，当你读这篇article时，肯定你已经熟悉了TCP那个三次握手，
或者是SYN,SYN|ACK,ACK. 而我要做的也就是这个，提取一个流的前N个packets，针对目前的需求，只需要在传输层截取UDP和TCP的前多少个流即可。
所以我得分析网络层的这些协议底层到底是怎么回事，在结合libpcap完成流的提取任务。</p>

<p>相对来说TCP还是个复杂的协议，而且值得清楚的认识以下。那么结合wireshark和代码来认识下TCP里面的东西。</p>

<!--more-->

<p><a href="https://github.com/aluenkinglee/stuff/blob/master/cplusplus/traffic_parser/b.pcap?raw=true" title="pcap文件">这里</a>是个已经准备好的pcap文件，本文结合这个文件对此进行描述。</p>

<p>这个文件分析的是微信在单一环境中的网络行为，所以比较简单。打开这个文件，找到开始的几个右键单击选择<code>Follow TCP Stream</code>，或者在filter那里输入<code>tcp.stream eq 1</code>可以看到这里。</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp1.png?raw=true" alt="Follow TCP Stream" title="Follow TCP Stream" /></p>

<h4 id="section">三次握手</h4>

<p>TCP利用了8个标志位，在头部位置，以此来控制链接的状态，对我们最有用的就是SYN，ACK，FIN了。</p>

<ul>
  <li>SYN - (Synchronize) Initiates a connection</li>
  <li>FIN - (Final) Cleanly terminates a connection</li>
  <li>ACK - Acknowledges received data</li>
</ul>

<p>下面将会看到，一个packet包含了多个flag set。</p>

<h6 id="flagssyn10">对于这个流的第一个，注意Flags里面出了SYN位是1之外，其它都是0。</h6>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp2.png?raw=true" alt="第一次握手" title="第一次握手" /></p>

<h6 id="synack">接下来在看第二个，注意它有两个标志位被设置为1，分别是SYN和ACK。</h6>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp3.png?raw=true" alt="第二次握手" title="第二次握手" /></p>

<h6 id="packetack">对于第三个packet，就只有ACK设置了。</h6>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp4.png?raw=true" alt="第三次握手" title="第三次握手" /></p>

<p>这就是最初的TCP三次握手。</p>

<h4 id="seqack">序列号和应答号（SEQ和ACK）</h4>

<p>假设客户端为A，服务器为B，双方都为护着一个32bit的序列号，用来追踪传输了多少数据。。这个号包括了之前所传输的负载的
大小，由另一端的应答号来应答“你传的数据我都收到了。。”</p>

<p>当一个机器开始初始TCP序列号时，它是随机的！！不然会出现序列号攻击。。（我忘记了，在用那个wireshark后成功被它的相对序列号迷惑了==）,是一个0～ $2^{32}-1$的数。相对序列号是给人看的，所以像wireshark之辈使用它是为了人们方便阅读理解的。
（选择不启用相对序列号：选择<code>Edit &gt; Preferences... </code>不启用那个<code>Relative sequence numbers and window scaling </code>就可以了）</p>

<p>接下来让我们结合下图来看这个流的行为。在<code>Statistics &gt; Flow Graph...</code>选择<code>TCP flow</code>。</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp5.png?raw=true" alt="流图" title="流图" /></p>

<p>这张图很容易理解就不说了。使用这张流图可以很方便的帮助我们理解他们是怎么工作的。</p>

<h6 id="packet-1">packet #1</h6>

<p>A向B发了一个请求，我们可以在frame的tcp中分析出来，SYN=1而ACK=0，这意味这是一个流的起始包。这里使用的是相对序列号，所以为0.</p>

<h6 id="packet-2">packet #2</h6>

<p>B收到了响应，恩，因为这是会话的开始，所以B这边也生成了一个随机的序列号，只不过在这里也显示为0了。SYN置为1。另外ACK也置为1，表明收到了A的响应。
(注意！虽然A没有发送任何负载payload，B仍然把ACK置为1，是因为收到的SYN或者FIN触发了这个增1行为。这儿不会涉及到任何负载长度的计算，因为带有这样信号的包不会携带负载的。)</p>

<h6 id="packet-3">packet #3</h6>

<p>和#2一样，A回应了B的响应（SEQ=0，ACK=1）所以ACK为1.自己的SEQ因为收到的包中有SYN所以变为1。此时，双方的SEQ都是1，这种现象在所有TCP开始建立连接时候都是一样的。</p>

<h6 id="packet-4">packet #4</h6>

<p>A这个包此时带有负载，这里的SEQ是1，因为上个包（#3）没有传输任何数据，ACK也是1，因为A没有传输任何数据。注意！packet的长度是341，但是我们计算的是传输层的数据长度–负载的长度，所以是ACK — LEN = LEN（#4）-LEN（#3） = 341 - 66 = 275。</p>

<h6 id="packet-5">packet #5</h6>

<p>这个包是B（#5）对A（#4）发送数据的响应，此时B的ACK加上负载的长度是275变为276，表示我B收到了你A传输的数据payload（#4）. B此时的SEQ仍为1.</p>

<h6 id="packet-6">packet #6</h6>

<p>这个包是B对A放送的HTTP响应，因为之前它（B）所有的包都没有负载，所以SEQ仍然为1，而ACK还是276.负载长度为627.</p>

<h6 id="packet-7">packet #7</h6>

<p>好吧，这个例子有点特殊，到这里为止B的数据就发送完了。。。所以FIN置为1，表明你（A）要得我（B）都给完了，没我的事儿了，SEQ加上我发送的数据长度为628，你那边确认之后应该和我一样才对。ACK还是之前你给我发送的那些数据，还是这些276.</p>

<h6 id="packet-8">packet #8</h6>

<p>A:收到了所有的数据，我先确认给你我数据我收到了，ACK加上627变为628。我之前发送的数据截止到目前是276，没错，我们对上了。</p>

<h6 id="packet-9">packet #9</h6>

<p>A:既然我都要到了，那么我们就分手吧~~ 同意，FIN置为1，因为从B收到了带有FIN的报文（#7），所以ACK+1，变为629。因为上个数据包#8 没有发送任何数据，所以这里的SEQ不变,</p>

<h6 id="packet-10">packet #10</h6>

<p>因为#9带有FIN，所以SEQ自增1.ACK不变。</p>

<p>关于代码，请看下篇。</p>

<h2 id="section-1">参考</h2>

<ol>
  <li>
    <p><a href="http://stackoverflow.com/questions/2672734/tcp-sequence-number-question">TCP sequence number question</a></p>
  </li>
  <li>
    <p><a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
</feed>
