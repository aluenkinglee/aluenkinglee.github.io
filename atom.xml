<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[曾经渐行远，未免心戚戚]]></title>
  <link href="http://aluenkinglee.com/atom.xml" rel="self"/>
  <link href="http://aluenkinglee.com/"/>
  <updated>2014-09-02T03:59:52+08:00</updated>
  <id>http://aluenkinglee.com/</id>
  <author>
    <name><![CDATA[Aluen King Lee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[浅谈微博标签聚合]]></title>
    <link href="http://aluenkinglee.com/blog/2014/09/02/qian-tan-wei-bo-biao-qian-ju-he/"/>
    <updated>2014-09-02T00:47:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/09/02/qian-tan-wei-bo-biao-qian-ju-he</id>
    <content type="html"><![CDATA[<p>标注问题在机器学习中是一个监督学习的问题，当然在这里我们所要面对是微博中用户给自己添加标签的
问题，并不是研究如何给用户添加标签。
浏览微博中用户的个人资料时，你会发现大部分用户都给自己添加了自认为所属类别的标签，这个很正确，
属于人工标注的典例。但是，细细浏览下每个人的标签我们会发现，其实好多标签的意思是一样的，比如
<code>苹果</code>，<code>iphone</code>，<code>iphone5</code>，的意思是类似的，还有<code>安卓</code>,<code>Android</code>,<code>智能手机</code>，<code>安卓手机</code>,
很明显，他们又是类，有没有办法把类似的标签聚集在一起呢？</p>

<p>直到现在，从我们的需求出发可以看到这是一个聚类问题，将相似的标签聚集到一起，并找出可以代表这
类相似标签的标签。</p>

<p>整体思路是根据用户的标签数据集得到“标签-用户”矩阵，考录到这个矩阵大部分为0值，所以使用稀疏矩阵
来降低内存无用消耗。然后使用一个相似度来代表距离，可以使用cosine相似度，pearson相似度，等等，
在这里使用的是余弦相似度，使用这里的算法进行聚类之后，得到聚类模型，如图所示。</p>

<p>接下来就是找到相似的标签，这个我们可以想象，从根节点开始，离根节点越远的拥有共同祖先的叶节点相似
越大，每个内节点都有一个代表它孩子的相似度，我们需要做的是，找到一个cutoff，然后，只要某个节点
小于该cutoff，那么认为他们之前没有相似关系，若大于改值，则意味这以改节点为祖先的叶节点是一个
簇，简单实用，而且效果不错。</p>

<p>到现在为止，我们找到了相似的标签集合，那么如何从集合中找到代表性的标签呢？一个显而易见的就是，计算
该标签被用户引用的次数，简单的总是最好的！</p>

<p>如图所示，这是按照上述思路完成的结果的一部分显示结果，数据太多，不方便显示。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[use svm to classify whether a person is good or bad on credit using sns data]]></title>
    <link href="http://aluenkinglee.com/blog/2014/07/12/use-svm-to-classify-whether-a-person-is-good-or-bad-on-credit-using-sns-data/"/>
    <updated>2014-07-12T17:21:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/07/12/use-svm-to-classify-whether-a-person-is-good-or-bad-on-credit-using-sns-data</id>
    <content type="html"><![CDATA[<p>首先说明这只是一个思路方向性的大概说明介绍，更多关于业务方面的内容不方便介绍。</p>

<p>如何评价一个人的金融信用，这个可以搜集用户的一些基本数据，比如职业，大学，社交数据来进行评分判断，至于为什么选取这些特征，一个很显然的理由就是
一个人越倾向使用社交应用，那么这个人就越可能是真实的，可信的。职业学校和人的信用也是成一定关系但不是绝对就是向我们想当然的那样。</p>

<p>之前的文章也断断续续的聊过伪匹配，分类的内容，是和此有一定关联。</p>

<p>对于模型的构建，方式有很多，贝叶斯网络，逻辑回归模型，svm模型，甚至是神经网络模型都可以对此进行建模使用，但是哪个性能更好呢？不知道，只有分别做出之后
比较才可以说明问题。</p>

<!-- more -->

<h4 id="svm">非线性SVM</h4>

<p>前面的blog有讲到线性svm，对于非线性分类器就要把x映射到特征空间,同时考虑误差ε的存在（即有些样本点会越过分类边界），上述优化问题变为：、</p>

<script type="math/tex; mode=display">
\min { \quad \frac { 1 }{ 2 } \left\| w \right\| ^{ 2 }+c\sum _{ i=1 }^{ l }{ { \xi  }_{ i } }  } \\ st.\quad y_{ i }(\omega ^{ T }\phi (x_i)-b)\ge 1-\xi _{ i },\left( \xi _{ i }>0 \right) 
</script>

<p>从输入空间是映射到特征空间的函数称为核函数，LibSVM中使用的默认核函数是RBF（径向基函数radial basis function），即</p>

<script type="math/tex; mode=display">
K(x,y)=exp{ \left( \frac { -\left\| x-y \right\| ^{ 2 } }{ 2\sigma ^{ 2 } }  \right)  }
</script>

<p>这样一来就有两个参数需要用户指定：c和gamma。实际上在LibSVM中用户需要给出一个c和gamma的区间，
LibSVM采用交叉验证cross-validation accuracy的方法确定分类效果最好的c和gamma。</p>

<p>举个例子说明什么是交叉验证，假如把训练样本集拆成三组，然后先拿 1 跟 2 来 train model 并 predict 3 以得到正确率；
再来拿 2 跟 3 train 并 predict 1 ，最后 1,3 train 并 predict 2 ，最后取预测精度最高的那组c和gamma。</p>

<h4 id="libsvm">libsvm</h4>

<p>点击<a href="http://www.csie.ntu.edu.tw/~cjlin/cgi-bin/libsvm.cgi?+http://www.csie.ntu.edu.tw/~cjlin/libsvm+tar.gz">here</a>下载libsvm.</p>

<p>看readme即可使用了。</p>

<p>LibSVM要求处理的文件数据都满足如下格式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">rlabel1 index1:value1   index2:value2   …...
</span><span class="line">rlabel2 index1:value1   index2:value2   …...
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>rlabel表示分类，为一个数字。Index从1开始递增，表示输入向量的序号，value是输入向量相应维度上的值，如果value为0,该项可以不写。下面是一个示例文件：</p>

<p>目前简单的分类所使用的属性有：年龄WOE   类型WOE   信用卡邮箱授权WOE  搜多引擎返回数WOE  贴吧搜索返回数WOE  微博数WOE  活跃度WOE  淘友朋友WOE 人人看过的人数WOE  好友数WOE  微博注册时间WOE
预测值为还款情况（还款1，逾期0）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">0 1:0.010003 2:-0.10524 3:0.131117521 4:0.061095504 5:0.029130009 6:-0.178635093 7:-0.149465309 8:-0.03275873 9:-0.047039163 10:-0.047039163 11:-0.158328769
</span><span class="line">0 1:0.010003 2:-0.10524 3:0.131117521 4:-0.025995297 5:-0.051360537 6:-0.090148625 7:-0.149465309 8:-0.005168969 9:0.000132475 10:-0.050262447 11:-0.158328769
</span><span class="line">0 1:-0.08606 2:-0.10524 3:0.131117521 4:-0.163782716 5:-0.051360537 6:-0.178635093 7:-0.149465309 8:-0.03275873 9:-0.047039163 10:-0.047039163 11:-0.158328769
</span><span class="line">0 1:-0.21088 2:0.009167 3:0.131117521 4:0.061095504 5:0.029130009 6:-0.090148625 7:-0.129577755 8:-0.03275873 9:0.000132475 10:-0.050262447 11:-0.226676962
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>svm_scale用于把输入向量按列进行规范化（或曰缩放）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">Usage: svm-scale <span class="o">[</span>options<span class="o">]</span> data_filename
</span><span class="line">options:
</span><span class="line">-l lower : x scaling lower limit <span class="o">(</span>default -1<span class="o">)</span>
</span><span class="line">-u upper : x scaling upper limit <span class="o">(</span>default +1<span class="o">)</span>
</span><span class="line">-y y_lower y_upper : y scaling limits <span class="o">(</span>default: no y scaling<span class="o">)</span>
</span><span class="line">-s save_filename : save scaling parameters to save_filename
</span><span class="line">-r restore_filename : restore scaling parameters from restore_filename
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>例如： <code>svm_scale -l 0 -u 1 -s range trainSet &gt; trainSet.scale</code>则输入文件是trainSet，输出文件是trainSet.scale，把输入向量的各列都缩放到[0，1]的范围内，range文件中保存了相关的缩放信息。</p>

<p>这个时候我们应该把训练集分为两部分，训练集和测试集，在训练集上通过交叉验证学到最佳的参数，然后在测试集上验证。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$python</span> subset.py
</span><span class="line">Usage: subset.py <span class="o">[</span>options<span class="o">]</span> dataset number <span class="o">[</span>output1<span class="o">]</span> <span class="o">[</span>output2<span class="o">]</span>
</span><span class="line">This script selects a subset of the given data set.
</span><span class="line">options:
</span><span class="line">-s method : method of selection <span class="o">(</span>default 0<span class="o">)</span>
</span><span class="line">
</span><span class="line">     0 -- stratified selection <span class="o">(</span>classification only<span class="o">)</span>
</span><span class="line">
</span><span class="line">     1 -- random selection
</span><span class="line">
</span><span class="line">output1 : the subset <span class="o">(</span>optional<span class="o">)</span>
</span><span class="line">
</span><span class="line">output2 : the rest of data <span class="o">(</span>optional<span class="o">)</span>
</span><span class="line">
</span><span class="line">If output1 is omitted, the subset will be printed on the screen.
</span><span class="line">
</span><span class="line"><span class="nv">$python</span> subset.py trainSet 0.3*m<span class="o">(</span>实例个数<span class="o">)</span> trainSet.data testSet.data
</span><span class="line"><span class="nv">$ </span>./tools/subset.py ./trainningset.txt 280 testSet trainSet
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>grid.py是一种用于RBF核函数的C-SVM分类的参数选择程序。用户只需给定参数的一个范围，grid.py采用交叉验证的方法计算每种参数组合的准确度来找到最好的参数。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="python"><span class="line"><span class="n">python</span> <span class="n">grid</span><span class="o">.</span><span class="n">py</span>
</span><span class="line"><span class="n">Usage</span><span class="p">:</span> <span class="n">grid</span><span class="o">.</span><span class="n">py</span> <span class="p">[</span><span class="o">-</span><span class="n">log2c</span> <span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">step</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">log2g</span> <span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">step</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">v</span> <span class="n">fold</span><span class="p">]</span>
</span><span class="line">       <span class="p">[</span><span class="o">-</span><span class="n">svmtrain</span> <span class="n">pathname</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">gnuplot</span> <span class="n">pathname</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">out</span> <span class="n">pathname</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">png</span> <span class="n">pathname</span><span class="p">]</span>
</span><span class="line">       <span class="p">[</span><span class="n">additional</span> <span class="n">parameters</span> <span class="k">for</span> <span class="n">svm</span><span class="o">-</span><span class="n">train</span><span class="p">]</span> <span class="n">dataset</span>
</span><span class="line"><span class="n">The</span> <span class="n">program</span> <span class="n">conducts</span> <span class="n">v</span><span class="o">-</span><span class="n">fold</span> <span class="n">cross</span> <span class="n">validation</span> <span class="n">using</span> <span class="n">parameter</span> <span class="n">C</span> <span class="p">(</span><span class="ow">and</span> <span class="n">gamma</span><span class="p">)</span><span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="n">begin</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="n">begin</span><span class="o">+</span><span class="n">step</span><span class="p">),</span> <span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="o">^</span><span class="n">end</span><span class="o">.</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>首先<code>sudo apt-get install gnuplot</code></p>

<p>然后编译C++版本的LibSVM，生成svm-train二进制可执行文件。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">python grid.py -log2c -5,5,1 -log2g -4,0,1 -v 5 -svmtrain /path/to/your/svm-train -m 500 trainSet.data <span class="o">(</span>svm-train 的路径自个找好<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>-m 500是使用svm_train时可以使用的参数。
最后输出两个文件：dataset.png绘出了交叉验证精度的轮廓图，dataset.out对于每一组log2(c)和log2(gamma)对应的CV精度值。</p>

<p>得到c=16，g=1</p>

<p>这个是我实验的截图</p>

<p><img src="https://raw.githubusercontent.com/aluenkinglee/mlclass/master/libsvm-3.18/trainSet.png" alt="实验截图" /></p>

<p>最后来训练我们的模型</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>./svm_train
</span><span class="line">
</span><span class="line">-s svm_type : <span class="nb">set type </span>of SVM <span class="o">(</span>default 0<span class="o">)</span>
</span><span class="line">0 -- C-SVC
</span><span class="line">-t kernel_type : <span class="nb">set type </span>of kernel <span class="k">function</span> <span class="o">(</span>default 2<span class="o">)</span>
</span><span class="line">0 -- linear: u<span class="err">&#39;</span>*v
</span><span class="line">2 -- radial basis <span class="k">function</span>: exp<span class="o">(</span>-gamma*|u-v|^2<span class="o">)</span>
</span><span class="line">-g gamma : <span class="nb">set </span>gamma in kernel <span class="k">function</span> <span class="o">(</span>default 1/num_features<span class="o">)</span> num_features是输入向量的个数
</span><span class="line">-c cost : <span class="nb">set </span>the parameter C of C-SVC, epsilon-SVR, and nu-SVR <span class="o">(</span>default 1<span class="o">)</span>
</span><span class="line">-m cachesize : <span class="nb">set </span>cache memory size in MB <span class="o">(</span>default 100<span class="o">)</span> 使用多少内存
</span><span class="line">-e epsilon : <span class="nb">set </span>tolerance of termination criterion <span class="o">(</span>default 0.001<span class="o">)</span>
</span><span class="line">-h shrinking : whether to use the shrinking heuristics, 0 or 1 <span class="o">(</span>default 1<span class="o">)</span>
</span><span class="line">-wi weight : <span class="nb">set </span>the parameter C of class i to weight*C, <span class="k">for </span>C-SVC <span class="o">(</span>default 1<span class="o">)</span> 当各类数量不均衡时为每个类分别指定C
</span><span class="line">-v n: n-fold cross validation mode交叉验证时分为多少组
</span><span class="line">-q : quiet mode <span class="o">(</span>no outputs<span class="o">)</span>
</span><span class="line">
</span><span class="line"><span class="nv">$ </span>svm_train -s 0 -c 16 -t 2 -g 1 -e 0.01 trainSet.scale
</span><span class="line"><span class="nv">$ </span>./svm-train -s 2 -c 16 -g 1 -v 5 ./trainSet
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>会得到训练结果，然后使用这个模型来预测测试集的数据准确性</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">./svm-predict testSet result
</span><span class="line">./svm-predict -b 0 testSet trainSet.model  result
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section">实验结果</h3>

<p>对数据进行格式转换后，首先对数据集进行分割得到训练集和测试集，选择常规比例为6：4</p>

<p>1.一开始未设置最有参数时即C和simga的值时，由训练集得到的模型分类性能在测试集上达到了Accuracy = 79.64285714285714% (223/280)的精度。</p>

<p>2.选择合适的参数。</p>

<p>通过交叉验证方法对模型进行选择得到针对训练集上最优的参数为c=16 g=1</p>

<p>由此得到的训练模型在测试集上的准确率达到了Accuracy = 81.4286% (228/280) (classification)，将近2%的精度提升，也算不错了。</p>

<p>目前由这些属性判断用户的还款情况，准确率在80%左右。但是预测结果全部预测为1.不合理。</p>

<p>实验结果准确率，在指定one-vs-class 之后，准确率为40%。比起逻辑回归模型仍然好点。</p>

<blockquote>
  <blockquote>
    <p>Ref</p>
  </blockquote>
</blockquote>

<p>数据可以到<a href="https://github.com/aluenkinglee/mlclass/tree/master/libsvm-3.18">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[伪匹配]]></title>
    <link href="http://aluenkinglee.com/blog/2014/07/09/wei-pi-pei/"/>
    <updated>2014-07-09T17:13:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/07/09/wei-pi-pei</id>
    <content type="html"><![CDATA[<p>这里提到的伪匹配的概念是指在网上搜索某些特征词，比如人名公司手机QQ号等内容时，网页反馈的结果：重要关键词在人看来是逻辑没有关联的时候就是伪匹配。</p>

<p>比如说，某XX，公司名，地点很明显的构成一个记录的时候，在人看来是个写在一起的，那么结果就是匹配的。相反，要是搜索词相距很远，那么就是伪匹配。</p>

<p>那么好，人工审核此类内容是否匹配时，是个无聊枯燥的工作内容，那么只好找机器帮忙，思路也很简单，分析样本伪匹配的原因是什么？和网页文档有什么不同？</p>

<p>对目标网页的分析可以发现，搜索词在目标网页中有时是结构化存在的，就是搜索词处在不同的节点中，节点关系为树中的关系，或者是兄弟关系，或者是父子关系。
同时还有非结构化的内容，比如搜索词是在同一个节点中，此时就不存在上述判断关系，只能由另外一种关系来处理。
<!-- more -->
接着说，当是结构化的关系的时候，从我们人的观点来看，他们应该是兄弟节点，相邻很近，或者用另外一个距离：节点到最近祖先再到另外一个节点的距离。此距离也是很近的。</p>

<p>当时非结构话的关系时，他们是在用一语意范围内，所以字符距离很近。</p>

<p>OK，有了上面的思路，我们所做的就是分析统计目标网页的结构，然后查看具体指标的范围。</p>

<p>首先看如何区分是否结构化，这个可以依靠text的长度来判断（这是分析后发现的）。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="octave"><span class="line"><span class="n">x1</span><span class="p">=[</span>54<span class="p">,</span>161<span class="p">,</span>70<span class="p">,</span>65<span class="p">,</span>66<span class="p">,</span>3369<span class="p">,</span>101<span class="p">,</span>50<span class="p">,</span>167<span class="p">];</span>
</span><span class="line"><span class="n">y1</span><span class="p">=[</span>1<span class="p">,</span>1<span class="p">,</span>1<span class="p">,</span>1<span class="p">,</span>1<span class="p">,</span>1<span class="p">,</span>1<span class="p">,</span>1<span class="p">,</span>1<span class="p">];</span>
</span><span class="line"><span class="n">x2</span><span class="p">=[</span>114265<span class="p">,</span>89406<span class="p">,</span>137824<span class="p">,</span>11300<span class="p">,</span>14001<span class="p">,</span>54575<span class="p">,</span>108596<span class="p">,</span>78197<span class="p">,</span>67810<span class="p">,</span>11948<span class="p">,</span>8660<span class="p">,</span>2677<span class="p">,</span>103724<span class="p">,</span>8686<span class="p">];</span>
</span><span class="line"><span class="n">y2</span><span class="p">=[</span>0 0 0 0 0 0 0 0 0 0 0 0 0 0<span class="p">];</span>
</span><span class="line"><span class="nb">figure</span> <span class="p">;</span>
</span><span class="line"><span class="nb">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="s">&#39;rx&#39;</span><span class="p">,</span><span class="s">&#39;MarkerSize&#39;</span><span class="p">,</span>10<span class="p">);</span>
</span><span class="line"><span class="nb">hold</span> <span class="n">on</span><span class="p">;</span>
</span><span class="line"><span class="nb">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="s">&#39;bo&#39;</span><span class="p">,</span><span class="s">&#39;MarkerSize&#39;</span><span class="p">,</span>10<span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>数据是分析后得到的。</p>

<p>分布图如下：</p>

<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match1.png" alt="是否结构化与最长文本长度分布图" title="是否结构化与最长文本长度分布图" /></p>

<p>从图形分界出来看，max(x1)=3369,min(x2)=2677,这个cutoff可以选取2677～3369之间的长度即可。</p>

<p>代码如下,摘选了函数的一部分，url是函数的形参。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">    <span class="k">try</span> <span class="o">{</span>
</span><span class="line">        <span class="n">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">Jsoup</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">url</span><span class="o">).</span><span class="na">get</span><span class="o">();</span>
</span><span class="line">        <span class="n">Vector</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;&gt;();</span>
</span><span class="line">        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">tagCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class="line">        <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">lenCount</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class="line">        <span class="n">Elements</span> <span class="n">content</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="na">getAllElements</span><span class="o">();</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class="line">        <span class="n">String</span> <span class="n">tag</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="n">Element</span> <span class="n">e</span> <span class="o">:</span> <span class="n">content</span><span class="o">)</span> <span class="o">{</span><span class="c1">// 此处就是遍历了</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">ownText</span><span class="o">().</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">nodeName</span><span class="o">();</span>
</span><span class="line">                <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">ownText</span><span class="o">().</span><span class="na">length</span><span class="o">();</span>
</span><span class="line">                <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ins</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
</span><span class="line">                <span class="n">ins</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
</span><span class="line">                <span class="n">map</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ins</span><span class="o">);</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">max</span> <span class="o">=</span> <span class="n">len</span><span class="o">;</span>
</span><span class="line">                    <span class="n">tag</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">lenCount</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">len</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">lenCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">len</span><span class="o">,</span> <span class="n">lenCount</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">len</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</span><span class="line">                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">lenCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">len</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">                <span class="k">if</span> <span class="o">(</span><span class="n">tagCount</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">tagCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">tagCount</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</span><span class="line">                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">                    <span class="n">tagCount</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span><span class="line">                <span class="o">}</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tagCount</span><span class="o">);</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lenCount</span><span class="o">);</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tag</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">max</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="c1">// TODO Auto-generated catch block</span>
</span><span class="line">        <span class="c1">// e.printStackTrace();</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接着在做搜索节点的距离值的分布，一个搜索词可以会出现在不同的位置，既然搜索词之间有关联效应，那么，即使出现位置很多，
也会有不同的搜索词因为语意关联的缘故，他们的节点距离是很近的，照这个思路，有了以下的分布图。</p>

<p>网页结构化中伪匹配,节点距离兄弟距离的分布图图示如下：</p>

<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match3.png" alt="网页结构化中伪匹配节点距离兄弟距离的分布图" title="网页结构化中伪匹配节点距离兄弟距离的分布图" /></p>

<p>这个尾部节点兄弟距离太大了，一定是伪匹配的的，看数据较小的距离分布。</p>

<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match4.png" alt="网页结构化中伪匹配节点距离兄弟距离的分布图" title="网页结构化中伪匹配节点距离兄弟距离的分布图" /></p>

<p>从图可以看出，节点距离和伪匹配的关系不大，主要是兄弟距离起作用。</p>

<p>而兄弟距离于未匹配的分布图：</p>

<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match5.png" alt="兄弟距离于未匹配的分布图" title="兄弟距离于未匹配的分布图" /></p>

<p>各个距离的直方图如下：</p>

<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match6.png" alt="兄弟距离于未匹配的直方图" title="兄弟距离于未匹配的直方图" /></p>

<p>其中X轴是兄弟距离长度，y是个数。范围值可以选在3-28之间。</p>

<p>而在无结构中，搜索词的语意判断就是文本距离，搜索词的下标靠的很近。图示如下：</p>

<p><img src="https://raw.githubusercontent.com/aluenkinglee/aluenkinglee.github.io/source/source/images/2014-07-09-wei-pi-pei/false%20match2.png" alt="间隔分布图" title="间隔分布图" /></p>

<p>文本长度的数据（取一个网页中搜索词之间距离的最小值）为<code>4 13 25 58 89 102 249 893 1356 2000 2445 3023 4243 12533 13234
</code>
,从这个可以看出，距离很大的肯定就是伪匹配了，最小值的这个不确定。</p>

<p>完整代码请看<a href="https://github.com/aluenkinglee/stuff/tree/master/java/match">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[朴素贝叶斯文本分类]]></title>
    <link href="http://aluenkinglee.com/blog/2014/06/27/po-su-bei-xie-si-wen-ben-fen-lei/"/>
    <updated>2014-06-27T13:11:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/06/27/po-su-bei-xie-si-wen-ben-fen-lei</id>
    <content type="html"><![CDATA[<p>回顾朴素贝叶斯(NB)分类器:</p>

<script type="math/tex; mode=display">
p(y_k|x)=\frac{p(y_k)p(x|y_k)}{p(x)}\propto p(y_k)p(x|y_k)=p(y_k)\prod_{i=1}^{d}{p(x_i|y_k)}
</script>

<p>对于文本分类任务,即对一篇文章进行分类,是 NLP 中最常见的机器学习任务。一般情
况下,类别从几个到几十不等,或者更多。使用朴素贝叶斯文分类器进行文本分类,我们需要首先考
虑特征是什么,即x如何表示;<script type="math/tex">p(x_i|y_k )</script>的物理意义是什么,如何计算。
对于特征方面,文本分类常规都是使用 bag-of-words 的特征,即以文章中出现的词作为
特征,而不考虑词语出现的顺序。朴素贝叶斯文分类器也一般使用这种形式。那么特征空间的大小,
就取决于词表(vocabulary)的大小,即语料集合中不重复词的个数。对于汉语来说,一般
几万到百万不等。</p>

<p>在 bag-of-words 的特征体系下,特征空间是确定了的,但是具体<script type="math/tex">x_i</script>的取值以及对应的
<script type="math/tex">p(x_i |y_k )</script>的物理意义却可以有不同的考虑,对应着不同的参数计算公式及分类器训练和预测
的实现。这取决于我们是否考虑词语在文章中出现的频次。</p>

<!-- more -->

<h4 id="bernoullinb">伯努力(Bernoulli)NB</h4>

<p>先看不考虑词频的情况。即只看某词语在某文章中是否出现,而不管出现了具体是多少次。
这种假设下,
每维特征的取值为 0-1,此时对应的 NB 分类器又被称为伯努力(Bernoulli)NB 分类器。
比如,如果词表是{2014、年、巴西、世界杯、足球赛、举行、是、第、20、届、球队},
某文档是“2014 年巴西世界杯足球赛是第 20 届世界杯足球赛 ”,那么特征空间是 11,该文档
特征向量是:</p>

<script type="math/tex; mode=display">
x = (1,1,1,1,1,0,1,1,1,1,0)
</script>

<p>此时,<script type="math/tex">p(x_i|y_k)</script>的物理意义可认为是:若文章为 k 类别,则第 i 特征(词表第 i 个词)出
现或者不出现的概率。那么:</p>

<script type="math/tex; mode=display">
p(x_i = 0|y_k ) = 1 − p(x_i = 1|y_k)
</script>

<p>习惯的,我们经常用<script type="math/tex">p(x_i |y_k )</script>来作为<script type="math/tex">p(x_i = 1|y_k)</script>同等含义的一种表示。那此时,原NB
模型的表达式可以写为:</p>

<script type="math/tex; mode=display">
p\left( { { y }_{ k } }|{ x } \right) \propto 
p\left( { y }_{ k } \right) \prod _{ i=1 }^{ d }{ \left\{ { \alpha  }_{ i }p\left( { { x }_{ i } }|{ { y }_{ k } } \right) 
+\left( 1-{ \alpha  }_{ i } \right) \left( 1-p\left( { { x }_{ i } }|{ { y }_{ k } } \right)  \right)  \right\}  } 
</script>

<p><script type="math/tex">\alpha_i</script> 表示第 i 个词在该文档中出现了,没出现则为0.
此时要非常注意,计算文章属于某个类别的得分的时候,不只要考虑该文章的 word,
还要考虑在词表中的但是在该文章中没出现的 word!这类词对得分的贡献是<script type="math/tex">1 − p(x_i |y_k )</script>。
因此伯努力 NB 下,分类的时间复杂度是 <script type="math/tex">O(Cd)</script>,C 是类别数,d 是词表大小。</p>

<p>那么伯努力 NB 下,p的参数估计表达式是多少呢?假设根据如上定义,及最大似然估
计,可以得到:</p>

<script type="math/tex; mode=display">
p\left( { { x }_{ i } }|{ { y }_{ k } } \right) 
=\frac { \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{t } \right\} I\{ x_{ i }\quad in\quad y_{ t }\}  }  }{ \sum _{ t=1 }^{ t }{ I\left\{ y_{ k }={ y }_{ t } \right\}  }  }
=\frac { 特征词i在第k类文章中出现的文章数 }{ 第k类文章数 } 
</script>

<p>其中函数I是指示函数，若x出现则值为1。可见,对于高频词,对应的这种条件概率是非常高的。 比如“的”(假设没去除停用词),其对应的条件概率值很可能会接近于 1.</p>

<p>再重复强调一下,此时的概率意义约束是:</p>

<script type="math/tex; mode=display">
p(x_i = 1|y_k) + p(x_i = 0|y_k ) = 1
</script>

<p>看一下伯努力 NB 下参数平滑的问题。使用加 1 平滑,即拉普拉斯平滑,此时在保证概
率意义下,其平滑公式应该为:</p>

<script type="math/tex; mode=display">
p(x_i |y_k ) = \frac{第 k 类文章中出现过第 i 词的文章数 + 1}{第k类文章数 + 2}
</script>

<p>提醒一下,此处分母加的值是 2,而不是词表大小。注意,平滑一定要使得平滑之后仍
满足概率意义。</p>

<h4 id="multinomialnb">多项式(Multinomial)NB</h4>

<p>当我们考虑文章内词语的频次,而不只是考虑出现或未出现,此时特征的取值不再
是 0-1,不过总的特征空间大小仍未变化。拿前面的例子来做对照,词表是{2014、年、
巴西、世界杯、足球赛、举行、是、第、20、届、球队},某文档是“2014 年巴西世界
杯足球赛是第 20 届世界杯足球赛”,此时该文章的特征向量为:</p>

<script type="math/tex; mode=display">
x = (1,1,1,2,2,0,1,1,1,1,0)
</script>

<p>此时对应的 NB 一般称为多项式 NB。设 m 为文章内的总词频数,对应的模型表达
式应该如下:</p>

<script type="math/tex; mode=display">
p(y_k|x)∝p(y_k)p(x|y_k)=p(y_k)
\frac{m!}{\prod_{i=1}^{d} x_i!}
\prod_{i=1}^{d}p(w_i|y_k)^{x_i}
∝p(y_k)\prod_{i=1}^{d}p(w_i|y_k)^{x_i}
</script>

<p>之所以可以省掉这个多项式系数,是因为它是和类别<script type="math/tex">y_k</script>无关的。而此时,第 k 类别的所有文章中第 i 词的分布概率:</p>

<script type="math/tex; mode=display">
p\left( { { w }_{ i } }|{ { y }_{ k } } \right)
 =\frac { \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{ t } \right\} x_{ i }^{ t } }  }
{ \sum _{ j=1 }^{ d }{ \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{ t } \right\} x_{ i }^{ t } }  }  } 
=\frac { 特征词i在第k类文章中出现的总词频数 }{ 第k文章总词频数 } 
</script>

<p>在多项式NB下,即使极高频词,其
<script type="math/tex">p(w_i|y_k)</script>也很难接近于 1,
另外其在模型中作用的时候是:<script type="math/tex">p(w_i|y_k)^{x_i}</script>.这时候的概率约束是:</p>

<script type="math/tex; mode=display">
\sum_{i=1}^{d}p(w_i|y_k)=1
</script>

<p>因此对应的加 1 平滑为:</p>

<script type="math/tex; mode=display">
p\left( { { w }_{ i } }|{ { y }_{ k } } \right) =\frac { \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{ t } \right\} x_{ i }^{ t } } +1 }
{ \sum _{ j=1 }^{ d }{ \sum _{ t=1 }^{ n }{ I\left\{ y_{ k }={ y }_{ t } \right\} x_{ i }^{ t } }  }  +d} 
</script>

<p>注意事项：</p>

<ul>
  <li>
    <p>训练时候对于词语平铺的文本,应该要做词的聚合,即行程 bag-of-words 的形式比较有利于后续统计计算,特别是对于伯努利 NB 必须做去重。当然,对于
多项式 NB,也可以顺次扫描累加。</p>
  </li>
  <li>
    <p>预测时候的概率连乘,为了防止精度损失,可以改用取 log 相加。</p>
  </li>
  <li>
    <p>对于短一些的文本,伯努利 NB 即可;对于长文本,考虑词频的多项式 NB 即
可。当然也可以使用 tf-idf 等特征值,仿照多项式 NB 的形式。</p>
  </li>
  <li>
    <p>预测时候,对于词表中出现但是本文章未出现的词语,伯努利 NB 下对得分有
贡献,多项式 NB 下不用考虑;对于在词表中未出现的词,都可以不予以考虑,
因为未登录词对各个类别的贡献是一样的。</p>
  </li>
</ul>

<h4 id="section">实验</h4>

<p>关于实验数据，可以到<a href="https://github.com/aluenkinglee/mlclass/tree/master/NativeBayes">这里</a>下载，训练集和测试集都已经很明白
总量在4000-的水平，result.dat是训练结果，可以看到测试集在训练数据的结果上准确率达到了100%。。这个是因为类别太少的缘故。只有3个类别，不过这个已经
可以看到朴素贝叶斯在工业界的应用可以达到较好的性能。</p>

<p>朴素贝叶斯分类器代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 训练目录下的样本集合</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @throws IOException</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">trainSamples</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">        <span class="n">NaiveBayes</span> <span class="n">classifier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NaiveBayes</span><span class="o">();</span>
</span><span class="line">        <span class="n">File</span> <span class="n">flist</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&quot;./data-trainning-set&quot;</span><span class="o">);</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="n">File</span> <span class="n">f</span> <span class="o">:</span> <span class="n">flist</span><span class="o">.</span><span class="na">listFiles</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">classifier</span><span class="o">.</span><span class="na">training</span><span class="o">(</span><span class="k">new</span> <span class="n">Instance</span><span class="o">(</span><span class="n">f</span><span class="o">));</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="n">classifier</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="s">&quot;result.dat&quot;</span><span class="o">));</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Trainning finished&quot;</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * specify the training dataset directory, and store result in the outfile</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @param directory</span>
</span><span class="line"><span class="cm">     * @param result</span>
</span><span class="line"><span class="cm">     * @throws IOException</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">trainSamples</span><span class="o">(</span><span class="n">String</span> <span class="n">directory</span><span class="o">,</span> <span class="n">String</span> <span class="n">outfile</span><span class="o">)</span>
</span><span class="line">            <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">        <span class="n">NaiveBayes</span> <span class="n">classifier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NaiveBayes</span><span class="o">();</span>
</span><span class="line">        <span class="n">File</span> <span class="n">flist</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">directory</span><span class="o">);</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="n">File</span> <span class="n">f</span> <span class="o">:</span> <span class="n">flist</span><span class="o">.</span><span class="na">listFiles</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">classifier</span><span class="o">.</span><span class="na">training</span><span class="o">(</span><span class="k">new</span> <span class="n">Instance</span><span class="o">(</span><span class="n">f</span><span class="o">));</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="n">classifier</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="n">File</span><span class="o">(</span><span class="n">outfile</span><span class="o">));</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Trainning finished&quot;</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 判断该实例所属的类别category</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @param doc</span>
</span><span class="line"><span class="cm">     * @return</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getCategory</span><span class="o">(</span><span class="n">Instance</span> <span class="n">doc</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">categories</span> <span class="o">=</span> <span class="n">VARIABLE</span><span class="o">.</span><span class="na">getCategories</span><span class="o">();</span>
</span><span class="line">        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">categories</span><span class="o">);</span>
</span><span class="line">        <span class="kt">double</span> <span class="n">best</span> <span class="o">=</span> <span class="n">Double</span><span class="o">.</span><span class="na">NEGATIVE_INFINITY</span><span class="o">;</span>
</span><span class="line">        <span class="n">String</span> <span class="n">bestName</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">c</span> <span class="o">:</span> <span class="n">categories</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="kt">double</span> <span class="n">current</span> <span class="o">=</span> <span class="n">getProbability</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">doc</span><span class="o">);</span>
</span><span class="line">            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">current</span><span class="o">);</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">best</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="n">best</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
</span><span class="line">                <span class="n">bestName</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">bestName</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 计算P（C)=该类型文档总数/文档总数，返回的数对数值</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @param category</span>
</span><span class="line"><span class="cm">     * @return</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getCategoryProbability</span><span class="o">(</span><span class="n">String</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="n">VARIABLE</span><span class="o">.</span><span class="na">getDocCount</span><span class="o">(</span><span class="n">category</span><span class="o">)</span> <span class="o">*</span> <span class="mf">1.0f</span>
</span><span class="line">                <span class="o">/</span> <span class="n">VARIABLE</span><span class="o">.</span><span class="na">getDocCount</span><span class="o">());</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 计算P(feature|cateogry),返回的是取对数后的数值</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @param feature</span>
</span><span class="line"><span class="cm">     * @param category</span>
</span><span class="line"><span class="cm">     * @return</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getFeatureProbability</span><span class="o">(</span><span class="n">String</span> <span class="n">feature</span><span class="o">,</span> <span class="n">String</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">VARIABLE</span><span class="o">.</span><span class="na">getFeatureCount</span><span class="o">();</span>
</span><span class="line">        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">log</span><span class="o">((</span><span class="n">VARIABLE</span><span class="o">.</span><span class="na">getDocCount</span><span class="o">(</span><span class="n">feature</span><span class="o">,</span> <span class="n">category</span><span class="o">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">)</span>
</span><span class="line">                <span class="o">/</span> <span class="o">(</span><span class="n">VARIABLE</span><span class="o">.</span><span class="na">getDocCount</span><span class="o">(</span><span class="n">category</span><span class="o">)</span> <span class="o">+</span> <span class="n">m</span><span class="o">));</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 计算给定实例文档属于指定类别的概率，返回的是取对数后的数值</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @param category</span>
</span><span class="line"><span class="cm">     * @param doc</span>
</span><span class="line"><span class="cm">     * @return</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getProbability</span><span class="o">(</span><span class="n">String</span> <span class="n">category</span><span class="o">,</span> <span class="n">Instance</span> <span class="n">doc</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">getCategoryProbability</span><span class="o">(</span><span class="n">category</span><span class="o">);</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">feature</span> <span class="o">:</span> <span class="n">doc</span><span class="o">.</span><span class="na">getWords</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">VARIABLE</span><span class="o">.</span><span class="na">containFeature</span><span class="o">(</span><span class="n">feature</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">                <span class="n">result</span> <span class="o">+=</span> <span class="n">getFeatureProbability</span><span class="o">(</span><span class="n">feature</span><span class="o">,</span> <span class="n">category</span><span class="o">);</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 加载训练结果</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @param file</span>
</span><span class="line"><span class="cm">     * @throws IOException</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">load</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">        <span class="n">DataInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataInputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">));</span>
</span><span class="line">        <span class="n">VARIABLE</span> <span class="o">=</span> <span class="n">Variable</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 保存训练结果</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @throws IOException</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="n">File</span> <span class="n">file</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">        <span class="n">DataOutput</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="n">FileOutputStream</span><span class="o">(</span><span class="n">file</span><span class="o">));</span>
</span><span class="line">        <span class="n">VARIABLE</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * 训练一篇文档</span>
</span><span class="line"><span class="cm">     * </span>
</span><span class="line"><span class="cm">     * @param doc</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">training</span><span class="o">(</span><span class="n">Instance</span> <span class="n">doc</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">VARIABLE</span><span class="o">.</span><span class="na">addInstance</span><span class="o">(</span><span class="n">doc</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>特征词类代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Feature</span> <span class="o">{</span>
</span><span class="line">    <span class="cm">/** 每个关键词在不同类别中出现的文档数量 */</span>
</span><span class="line">    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">docCountMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class="line">    <span class="cm">/** 特征名称 */</span>
</span><span class="line">    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">incDocCount</span><span class="o">(</span><span class="n">String</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">docCountMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">category</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">            <span class="n">docCountMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">category</span><span class="o">,</span> <span class="n">docCountMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">category</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">            <span class="n">docCountMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">category</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getDocCount</span><span class="o">(</span><span class="n">String</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">docCountMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">category</span><span class="o">))</span> <span class="o">{</span>
</span><span class="line">            <span class="k">return</span> <span class="n">docCountMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">category</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">DataOutput</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">        <span class="n">out</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="n">name</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="n">name</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">        <span class="n">out</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">docCountMap</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">category</span> <span class="o">:</span> <span class="n">docCountMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
</span><span class="line">            <span class="n">out</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="n">category</span><span class="o">);</span>
</span><span class="line">            <span class="n">out</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">docCountMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">category</span><span class="o">));</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">readFields</span><span class="o">(</span><span class="n">DataInput</span> <span class="n">in</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">        <span class="n">docCountMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;();</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class="line">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">String</span> <span class="n">category</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
</span><span class="line">            <span class="kt">int</span> <span class="n">docCount</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class="line">            <span class="n">docCountMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">category</span><span class="o">,</span> <span class="n">docCount</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Feature</span> <span class="nf">read</span><span class="o">(</span><span class="n">DataInput</span> <span class="n">in</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class="line">        <span class="n">Feature</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Feature</span><span class="o">();</span>
</span><span class="line">        <span class="n">f</span><span class="o">.</span><span class="na">readFields</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">f</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="c1">// TODO Auto-generated method stub</span>
</span><span class="line">
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更多代码请看<a href="https://github.com/aluenkinglee/mlclass/tree/master/NativeBayes/src">这里</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拉格朗日对偶]]></title>
    <link href="http://aluenkinglee.com/blog/2014/06/03/lagrange-duality/"/>
    <updated>2014-06-03T21:41:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/06/03/lagrange-duality</id>
    <content type="html"><![CDATA[<p>在解决约束最优化的额问题中，常常利用拉格朗日对偶性将原始问题转化为对偶问题，通过解对偶问题得到原始问题的解。该方法主要应用的SVM和最大熵模型中。</p>

<p>先抛开上面的二次规划问题，先来看看存在等式约束的极值问题求法，比如下面的最优化问题：</p>

<script type="math/tex; mode=display">
\min _{ w }{ f\left( w \right)  } \\ s.t\quad h_{ i }\left( w \right) =0,\quad i=1,\cdots ,l
</script>

<p>目标函数是f(w)，下面是等式约束。通常解法是引入拉格朗日算子，这里使用<script type="math/tex">\beta</script>来表示算子，得到拉格朗日公式为</p>

<!-- more -->

<script type="math/tex; mode=display">
L \left( w,\beta  \right) =f\left( w \right) +\sum _{ i=1 }^{ l }{ \beta _{ i }h_{ i } } \left( w \right) 
</script>

<p>L是等式约束的个数。</p>

<p>然后分别对w和 <script type="math/tex">\beta</script>求偏导，使得偏导数等于0，然后解出w和 <script type="math/tex">\beta_i</script>。至于为什么引入拉格朗日算子可以求出极值，原因是f(w)
的dw变化方向受其他不等式的约束，dw的变化方向与f(w)的梯度垂直时才能获得极值，而且在极值处，f(w)的梯度与其他等式梯度的线性组合平行，因此他们之间存在线性关系。（参考《最优化与KKT条件》）
然后我们探讨有不等式约束的极值问题求法，问题如下：</p>

<script type="math/tex; mode=display">
\min _{ w }{ f\left( w \right)  } \\ 
s.t\quad h_{ i }\left( w \right) =0,\quad i=1,\cdots ,l\\ 
\quad \quad \quad g_{ i }\left( w \right) \le 0,\quad i=1,\cdots ,k
</script>

<p>我们定义一般化的拉格朗日公式</p>

<script type="math/tex; mode=display">
L\left( w,\beta  \right) =f\left( w \right) +\sum _{ i=1 }^{ k }{ \alpha _{ i }g_{ i } } \left( w \right) \sum _{ i=1 }^{ l }{ \beta _{ i }h_{ i } } \left( w \right) 
</script>

<p>这里的<script type="math/tex">\alpha _{ i } </script>和<script type="math/tex">\beta _{ i } </script> 都是拉格朗日算子。如果按这个公式求解，会出现问题，因为我们求解的是最小值，而这里的 <script type="math/tex">g_{ i } \left( w \right) </script>已经不是0了，我们可以将 <script type="math/tex">\alpha _{ i } </script>调整成很大的正值，来使最后的函数结果是负无穷。因此我们需要排除这种情况，我们定义下面的函数：</p>

<script type="math/tex; mode=display">
{ \theta  }_{p  }\left( w \right) =\max _{ \alpha ,\beta :{ \alpha  }_{ i }\ge 0 }{ L\left( w,\alpha ,\beta  \right)  } 
</script>

<p>这里的P代表primal。假设<script type="math/tex">g_{ i }\left( w \right)</script> &gt;0 或者<script type="math/tex">h_{ i }\left( w \right) \neq 0</script> ，那么我们总是可以调整 <script type="math/tex">\alpha_i</script>和<script type="math/tex">\beta_i</script> 来使得<script type="math/tex"> { \theta  }_{ p  }\left( w \right)</script>有最大值为正无穷。而只有g和h满足约束时，<script type="math/tex"> { \theta  }_{ p }\left( w \right)</script> 为f(w)。这个函数的精妙之处在于 <script type="math/tex">\alpha_i \ge 0</script>，而且求极大值。</p>

<p>因此,</p>

<script type="math/tex; mode=display">
{ \theta  }_{ p  }\left( w \right) =\begin{cases} f\left( w \right) ,\quad w满足原始问题约束 \\ +\infty ，其他\quad  \end{cases}
</script>

<p>所以如果考虑极小化问题</p>

<script type="math/tex; mode=display">
{ \min _{ w }{ { \theta  }_{p  }\left( w \right)  }  }={ \min _{ w }{ \max _{ \alpha ,\beta :{ \alpha  }_{ i }\ge 0 }{ L\left( w,\alpha ,\beta  \right)  }  }  }
</script>

<p>它是原始问题的等价解，原始最优化问题转化成了拉格朗日函数的极小极大问题，这时候把原始问题的最优值记为：</p>

<script type="math/tex; mode=display">
{ p }^{ \ast  }=\min _{ w }{ { \theta  }_{ p }\left( w \right)  } 
</script>

<p>哎哟，看看我们的等价形式哦，首先有两个参数，其中还是一个不等式约束=。=,考虑下对偶吧，极小极大问题转化为等价的极大极小问题。</p>

<h4 id="section">对偶形式</h4>

<p>定义<script type="math/tex">{ \theta  }_{ D }\left( \alpha ,\beta  \right) =\min _{ w }{ L\left( w,\alpha ,\beta  \right)  } </script>，在考虑极大化<script type="math/tex">{ \theta  }_{ D }\left( \alpha ,\beta  \right) </script>,先把这两个参数看成固定值，求关于w的最小值，之后在求对偶的最大值即</p>

<script type="math/tex; mode=display">
\max _{ \alpha ,\beta :{ \alpha  }_{ i }\ge 0 }{ { \theta  }_{ D }\left( \alpha ,\beta  \right)  } =\max _{ \alpha ,\beta :{ \alpha  }_{ i }\ge 0 }{ \min _{ w }{ L\left( w,\alpha ,\beta  \right)  }  } 
</script>

<p>这个问题是原问题的对偶问题，相对于原问题只是更换了min和max的顺序，而一般更换顺序的结果是Max Min(X) &lt;= MinMax(X)。然而在这里两者相等。用<script type="math/tex">{ d }^{ \ast  }</script> 来表示对偶问题如下：</p>

<script type="math/tex; mode=display">
{ d }^{ \ast  }=\max _{ \alpha ,\beta :{ \alpha  }_{ i }\ge 0 }{ \min _{ w }{ L\left( w,\alpha ,\beta  \right)  }  } \le { \min _{ w }{ \max _{ \alpha ,\beta :{ \alpha  }_{ i }\ge 0 }{ L\left( w,\alpha ,\beta  \right)  }  }  }={ p }^{ \ast  }
 </script>

<p>存在 <script type="math/tex">{ w }^{ \ast  },{ \alpha }^{ \ast  },{ \beta }^{ \ast  }</script> 使得<script type="math/tex">{ w }^{ \ast  }</script>是原问题的解，<script type="math/tex">{ \alpha }^{ \ast  },{ \beta }^{ \ast  }</script>  是对偶问题的解。还有 <script type="math/tex">{ p }^{ \ast  }={ d}^{ \ast  } = L({ w }^{ \ast  },{ \alpha }^{ \ast  },{ \beta }^{ \ast  })</script> </p>

<p>另外，  <script type="math/tex">{ w }^{ \ast  },{ \alpha }^{ \ast  },{ \beta }^{ \ast  }</script> 满足库恩-塔克条件（Karush-Kuhn-Tucker, KKT condition），该条件如下：</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-06-03-lagrange-duality/kkt.png?raw=true 库恩-塔克条件（Karush-Kuhn-Tucker, KKT condition）&quot;" alt="库恩-塔克条件（Karush-Kuhn-Tucker, KKT condition）" /></p>

<p>所以如果 <script type="math/tex">{ w }^{ \ast  },{ \alpha }^{ \ast  },{ \beta }^{ \ast  }</script>  满足了库恩-塔克条件，那么他们就是原问题和对偶问题的解。当<script type="math/tex">g_{i}(w^{ \ast  })=0</script> 时，w处于可行域的边界上，这时才是起作用的约束。而其他位于可行域内部（ <script type="math/tex">% &lt;![CDATA[
g_{i}(w^{ \ast  })<0 %]]&gt;</script> 的）点都是不起作用的约束，其 <script type="math/tex">{ \alpha }^{ \ast  }=0</script>。这个KKT双重补足条件会用来解释支持向量和SMO的收敛测试。</p>

<p>KKT的总体思想是将极值会在可行域边界上取得，也就是不等式为0或等式约束里取得，而最优下降方向一般是这些等式的线性组合，其中每个元素要么是不等式为0的约束，要么是等式约束。对于在可行域边界内的点，对最优解不起作用，因此前面的系数为0。</p>

<blockquote>
  <blockquote>
    <p>参考</p>
  </blockquote>
</blockquote>

<ol>
  <li>
    <p>Andrew Ng的原始课件讲义</p>
  </li>
  <li>
    <p>统计学习方法</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从逻辑回归分类到SVM分类]]></title>
    <link href="http://aluenkinglee.com/blog/2014/06/03/my-understanding-about-svm/"/>
    <updated>2014-06-03T20:53:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/06/03/my-understanding-about-svm</id>
    <content type="html"><![CDATA[<p>上一章讲到了线性回归的一个典型算法，核心思想就是利用最小二乘法最为损失函数，不断使用梯度下降法（或者使用随机梯度下降法（stochastic gradient descent））来更新theta值。</p>

<p>后来降到了分类，逻辑回归只不过有个很好的性质就是值分布在0到1之间，正好可以利用到分类上。logistic回归就是要学习得到θ，使得正例的特征远大于 0，负例的特征远
小于 0，强调在全部训练实例上达到这个目标。为什么说逻辑回归是个线性模型？这是因为该模型是将特性的线性组合作为自变量，然后使用logistic函数（或者说是sigmoid函数）将自变量映射到（0-1）上，将值和概率结合之后从而应用到分类上。
函数表示形式：</p>

<script type="math/tex; mode=display">
h_{ \theta  }\left( x \right) =g\left( \theta ^{ T }x \right) =\frac { 1 }{ 1+{e  }^{ -\theta^{T}x } }
</script>

<!-- more -->

<p>其中 x 是 n 维特征向量，函数 g 就是 logistic 函数
从线性回归到了逻辑回归，从逻辑回归又到了分类，那么再来看看SVM这个有监督的分类学习算法。
在这里我们使用的y的取值记为1和-1，所以对logistic 回归中的做下替换，令logistic回归中的y=0和y=1变为y=-1,y=1。同时将θ替换成 w 和 b。
所以有<script type="math/tex">\Theta^{T}x=\theta_0x_0+\theta_1x_1+\cdots +\theta_nx_n</script>，现在使用b替换<script type="math/tex">\theta_0</script>,替换后的形式变为<script type="math/tex">w^{ T }x=w_{ 1 }x_{ 1 }+\cdots +w_{ n }x_{ n }+b</script>，这样做之后，我们的假设函数就变成了</p>

<script type="math/tex; mode=display">
h_{ b,w }\left( x \right) =g\left( w^{ T }x+b \right)
</script>

<p>和逻辑回归的形式很相像。</p>

<p>表达形式就引申到这里，在来谈下SVM的思想，当我们学习线性回归时，我们的想法就是使用最小二乘法拟合数据，而在分类问题中，我们的想法就是找到一条直线，使正负样本离这个线或者超平面尽可能的远。也就是<code>间隔</code>最大。用一句话来说就是：<strong>在特征空间上的间隔最大的线性分类器。所以我们所有的努力都在如何是间隔最大化上，而这个可以转化为一个凸二次规划的问题</strong>。所以SVM的学习算法就是求解凸二次规划的最优化算法。</p>

<h5 id="functional-margingeometric-margin">函数间隔（functional margin）和几何间隔（geometric margin）</h5>

<p>我们定义函数间隔就是：对于给定的数据集T和超平面（w,b），样本点<script type="math/tex">\left( x^{(i)},y^{(i)} \right) </script>到超平面的函数间隔为：
$$
\widehat { \gamma  } ^{ (i) }=y^{ (i) }(w^{T}\cdot x^{ (i) }+b) 
$$</p>

<p>函数间隔或者间隔本身描述了一种确信度。离超平面越远，间隔值就越大，可信度就越大。</p>

<p>刚刚我们定义的函数间隔是针对某一个样本的，现在我们定义全局样本上的函数间隔，定义超平面关于数据集的函数间隔为超平面中所有样本点函数间隔的最小值，就是在训练样本上分类正例和负例确信度最小那个函数间隔，即</p>

<script type="math/tex; mode=display">
\widehat {\gamma }=\min _{ i=1,...m }{ \widehat { \gamma  } ^{ (i) } }
</script>

<p>但是有个问题，如果按比例的增加w和b，那么函数间隔也会按比例改变，这个对结果没有影响，但是问题会变得不好描述，不能定量的计算，所以我们就需要把它规范化(normalization)。只需要结果除以<script type="math/tex">\left\| w \right\| </script>就好了，这个时候<script type="math/tex">w/\left\| w \right\| </script>就成为了单位向量，所以函数间隔和几何间隔的关系也就是这样简单，几何间隔就是规范化后的函数间隔。无论w和b怎么折腾，几何间隔都不会改变。</p>

<p>定义几何间隔就是：对于给定的数据集T和超平面（w,b），样本点<script type="math/tex">\left( x^{(i)},y^{(i)} \right) </script>到超平面的几何间隔为：</p>

<script type="math/tex; mode=display">
{ \gamma  } ^{ (i) }=y^{ (i) }(w^{T}\cdot x^{ (i) }+b)/\left\| w \right\|
</script>

<p>定义超平面关于数据集的几何间隔为超平面中所有样本点几何间隔的最小值,即</p>

<script type="math/tex; mode=display">
{ \gamma  }=\min _{ i=1,...m }{ { \gamma  }^{ (i) } }
</script>

<p>最优间隔分类器（optimal margin classifier）（利用间隔最大化）</p>

<p>回想前面我们提到我们的目标是寻找一个超平面，使得离超平面比较近的点能有更大的
间距。 也就是我们不考虑所有的点都必须远离超平面，我们关心求得的超平面能够让所有点中离它最近的点具有最大间距。形象的说，我们将上面的图看作是一张纸，我们要找一条折线，按照这条折线折叠后，离折线最近的点的间距比其他折线都要大。形式化表示为：</p>

<script type="math/tex; mode=display">
\max _{ \gamma ,w,b }{ \gamma  } \\ s.t\quad { y }^{ \left( i \right)  }\left( { w }^{ T }{ x }^{ \left( i \right)  }+b \right) \ge \gamma ,i=1,\cdots ,m\\ \left\| w \right\| =1
</script>

<table>
  <tbody>
    <tr>
      <td>这里用</td>
      <td> </td>
      <td>w</td>
      <td> </td>
      <td>=1 规约 w，使得<script type="math/tex"> w^{T}\cdot x+b</script>是几何间隔。</td>
    </tr>
  </tbody>
</table>

<p>到此，我们已经将模型定义出来了。如果求得了 w 和 b，那么来一个特征 x，我们就能
够分类了，称为最优间隔分类器。接下的问题就是如何求解 w 和 b 的问题了。</p>

<p>由于||w|| = 1不是凸函数，我们想先处理转化一下，考虑几何间隔和函数间隔的关系，
<script type="math/tex"> \gamma =\frac { \hat { \gamma  }  }{ \left\| w \right\|  } </script>，我们改写一下上面的式子：</p>

<script type="math/tex; mode=display">
\max _{ \gamma ,w,b }{ \frac { \widehat { \gamma  }  }{ \left\| w \right\|  }  } \\ s.t\quad { y }^{ \left( i \right)  }\left( { w }^{ T }{ x }^{ \left( i \right)  }+b \right) \ge \widehat { \gamma  } ,i=1,\cdots ,m
</script>

<p>因为函数间隔值得改变对结果没有影响，所以可以给它个固定值比如1.将 <script type="math/tex">\hat { \gamma  } =1</script>代入上面的最优化问题，因为最大化<script type="math/tex"> \frac { 1 }{ \left\| w \right\|  } </script>最小化<script type="math/tex"> \frac { 1 }{ 2 } \left\| w \right\| ^{ 2 }</script>是等价的，于是将上面改写成这样：</p>

<script type="math/tex; mode=display">
\min _{ \gamma ,w,b }{ \frac { 1 }{ 2 }  } { \left\| w \right\|  }^{ 2 }\\ s.t\quad { y }^{ \left( i \right)  }\left( { w }^{ T }{ x }^{ \left( i \right)  }+b \right) -1\ge 0,i=1,\cdots ,m
</script>

<p>这就变成了一个凸二次规划问题，详情见<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92">凸二次规划</a></p>

<p>接下来是关于拉格朗日对偶的问题，在这之后，在描述SVM中最简单的分类器——<strong>线性可分支持向量机</strong>，因为这个情况下，数据是线性可分的，而且噪音没有，只需要通过<strong>硬间隔最大化</strong>,即可学习一个线性的分类器，又称硬间隔支持向量机。</p>

<blockquote>
  <blockquote>
    <p>参考</p>
  </blockquote>
</blockquote>

<ol>
  <li>
    <p>Andrew Ng的原始课件讲义</p>
  </li>
  <li>
    <p>统计学习方法</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下通过端口杀死进程]]></title>
    <link href="http://aluenkinglee.com/blog/2014/05/20/kill-process-on-some-port-under-linux-platform/"/>
    <updated>2014-05-20T10:41:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/05/20/kill-process-on-some-port-under-linux-platform</id>
    <content type="html"><![CDATA[<p>就是把一些常用命令记录下来拉。一直在用，可就是容易忘记命令。</p>

<p>floodlight 控制器启动之后，因为不正常的关闭程序（ctrl+c）造成6633端口还在被占用。</p>

<p>流程如下：</p>

<ol>
  <li>
    <p>netstat -nlp 查看占用端口号的服务</p>
  </li>
  <li>
    <p>找到该端口号的进程，可以使用grep</p>
  </li>
  <li>
    <p>找到该进程id</p>
  </li>
  <li>
    <p>kill pid</p>
  </li>
</ol>

<h5 id="section">查看占用端口号的服务</h5>

<p>可以使用netstat命令</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">Active Internet connections (only servers)
</span><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
</span><span class="line">Active Internet connections (only servers)
</span><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
</span><span class="line">tcp        0      0 0.0.0.0:6633            0.0.0.0:*               LISTEN      6267/java
</span><span class="line">tcp        0      0 0.0.0.0:3307            0.0.0.0:*               LISTEN      12711/
</span><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3936/httpd
</span><span class="line">tcp        0      0 0.0.0.0:21              0.0.0.0:*               LISTEN      3910/
</span><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      3753/sshd
</span><span class="line">tcp        0      0 0.0.0.0:25              0.0.0.0:*               LISTEN      3786/
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>######用管道符给grep处理</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"> netstat -nlp | grep 6633
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>既然取出一行了，那就容易了，再筛选一下，用awk分割取出其中一个</p>

<h6 id="section-1">读取出端口号</h6>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">netstat -nlp | grep 6633 | awk <span class="s1">&#39;{print $7}&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>6267/java</p>

<p>意思是取第七个字段，这里默认应该是用tab字符分割的，已经读取出来了，但是还得拿到/前面的数字</p>

<h6 id="awk">取/前面的数字就可以了，这里还是可以用awk处理</h6>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">netstat -nlp | grep 6633 | awk <span class="s1">&#39;{print $7}&#39;</span> | awk -F<span class="s2">&quot;/&quot;</span> <span class="s1">&#39;{ print $1 }&#39;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>6267</p>

<h6 id="kill">把这个数字传给kill就可以</h6>

<p>kill命令不能跟在管道符后面继续处理了，会出错的.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nb">kill</span> <span class="o">[</span><span class="s1">&#39;] netstat -nlp | grep 6633 | awk &#39;</span><span class="o">{</span>print <span class="nv">$7</span><span class="o">}</span><span class="s1">&#39; | awk -F&quot;/&quot; &#39;</span><span class="o">{</span> print <span class="nv">$1</span> <span class="o">}</span><span class="s1">&#39; [&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<blockquote>
  <blockquote>
    <p>其它类似的命令</p>
  </blockquote>
</blockquote>

<ol>
  <li>查看端口属于哪个程序？端口被哪个进程占用</li>
</ol>

<p>也可以使用lsof命令。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line"><span class="nv">$ </span>lsof -i :6633
</span><span class="line">
</span><span class="line">COMMAND   PID   USER      FD   TYPE    DEVICE  SIZE/OFF NODE NAME
</span><span class="line">java    7838   kinglee   50r   IPv6  35452317       0t0  TCP *:6633 <span class="o">(</span>LISTEN<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="reference">reference</h4>

<ol>
  <li>
    <p><a href="http://baike.baidu.com/link?url=idG3yCyykQj00QVBW_jreekVZWjIGU5urL553dG9o4ZYgwpbnjd7jJ2DVjxrm5EZ">netstat</a></p>
  </li>
  <li>
    <p><a href="http://www.cnblogs.com/peter9/archive/2011/07/28/2362156.html">Linux下通过端口杀死进程</a></p>
  </li>
  <li>
    <p><a href="http://blog.csdn.net/andy572633/article/details/7211546">linux下杀死进程（kill）的N种方法</a></p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[threading:why import it into os]]></title>
    <link href="http://aluenkinglee.com/blog/2014/05/19/threading-why-import-it-into-os/"/>
    <updated>2014-05-19T23:14:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/05/19/threading-why-import-it-into-os</id>
    <content type="html"><![CDATA[<p>线程的引入是为了提高CPU利用率。线程给操作系统带来的创建维护和管理负担要轻。因为与线程相关的信息比较少，交情的负担意味着线程的代价或开销比较少。当处理器除一个进程并激活另一个进程时，就要发生上下文切换。为了发生上下文切换，操作系统必须启动和重新启动每个进程所需的信息。这就意味着必须保存描述进程存在状态的有关信息，在进程再次激活时，就可以从离开的地点继续执行。</p>

<h6 id="section">那么系统在进程切换时需要保存那些信息呢？</h6>

<ol>
  <li>
    <p>所需信息包括可执行程序、堆栈、以及静态与动态分配变量内存的指针。</p>
  </li>
  <li>
    <p>寄存器组中包含执行下一条指令的指针这样的信息 。</p>
  </li>
  <li>
    <p>重新任命进程时需要进程的状态（进程是被挂起还是被阻塞）和优先权。同时程序的I/O状态也被保存。</p>
  </li>
  <li>
    <p>保存进程的规划信息，内存管理信息以及计数信息。</p>
  </li>
  <li>
    <p>进程需要文件描述器和读写指针来继续使用资源。</p>
  </li>
</ol>

<h6 id="section-1">而线程同样需要上下文。当线程被抢先时同样也会发生上下文切换。</h6>

<h6 id="section-2">与进程相比线程的优势如下：</h6>

<ol>
  <li>
    <p>线程不需要地址空间。线程包含在进程的地址空间中。（所以在重新任命进程时所需的线程都不需要）</p>
  </li>
  <li>
    <p>线程的上下文只包含一个堆栈、一个寄存器组和一个优先权。</p>
  </li>
  <li>
    <p>寄存器组包含程序或指令指针以及堆栈指针。</p>
  </li>
  <li>
    <p>线程的文本包含在他的进程的文本中。</p>
  </li>
  <li>
    <p>进程拥有的所有资源都属于线程。所以与资源相关的所有信息不是线程上下文的部分。</p>
  </li>
  <li>
    <p>其他信息如规划、计数等都是由进程所定义。无需包含在线程的上下文中。</p>
  </li>
</ol>

<p>线程与进程的相同之处是：都有ID，寄存器组、状态、以及优先权。线程与子进程共享父进程的资源。</p>

<h6 id="section-3">他们的不同之处是：</h6>

<ol>
  <li>
    <p>线程没有自己的地址空间，如果进程创建了多个所有的线程都将包含在他的地址空间中。</p>
  </li>
  <li>
    <p>父进程和子进程之间必须通过进程间通信机制来进行通信。而进程中的多个线程之间是通过读取和写入数据到进程变量来通信。</p>
  </li>
  <li>
    <p>子进程对其他子进程不施加控制，而进程的线程被看做同位体（peer）并对进程的其他的线程施加控制。</p>
  </li>
</ol>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我对KMP算法的理解]]></title>
    <link href="http://aluenkinglee.com/blog/2014/05/19/my-understanding-about-kmp/"/>
    <updated>2014-05-19T22:56:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/05/19/my-understanding-about-kmp</id>
    <content type="html"><![CDATA[<p>和朴素的字符串匹配算法相比，KMP加快匹配的关键在于当某个位置不匹配了，不在模版不再是向右滑动一个位置，而是跟匹配处相关的一个值。这样，在字符串的匹配时间就是和搜索串长度相关的一个值<script type="math/tex">O(n)</script>。</p>

<p>至于相关的资料，参阅了<a href="http://blog.csdn.net/v_july_v/article/details/7041827">六之再续：KMP算法之总结篇（12.09修订，必懂KMP</a>，只是这个个人感觉有点凌乱。</p>

<p>定义要搜索的字符串模式是<script type="math/tex">P</script>,搜索的源是文本<script type="math/tex">T</script>.那让我们看看next数组怎么诞生的。</p>

<h4 id="section">局部匹配表</h4>

<p>理解KMP算法的关键就是<strong>局部匹配表</strong>,或者形象的称作为<strong>next数组</strong>，
<a href="http://book.douban.com/subject/1885170/">算法导论</a>p571页详细的描述了推导的过程，并给出了证明。但是仍然还是晦涩难懂的。</p>

<p>对于这个推论：设<script type="math/tex">P</script>是长度为<script type="math/tex">m</script>的模式，next是P的前缀函数，对于<script type="math/tex">q=2,3,...,m</script></p>

<script type="math/tex; mode=display">% &lt;![CDATA[

next\left[ q \right] =\begin{Bmatrix} 0 & \quad if\quad { E }_{ q }\quad =\quad \phi  \\ 1+max\{ k\in { E }_{ q-1 }\}  & \quad if\quad { E }_{ q-1 }\quad =\phi  \end{Bmatrix}
 %]]&gt;</script>

<p>直观来说就是才用动规的方法，求<script type="math/tex">next\left[ q \right]</script>的最长前缀的长度。</p>

<p>那么好吧，再来个直观点的手写算法吧╮(╯▽╰)╭。</p>

<p>就以书上的例子为准，见下图。</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-05-19-my-understanding-about-kmp/1.png?raw=true" alt="a)" title="a)" /></p>

<p>前q=5个字符匹配，标记为绿色。</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-05-19-my-understanding-about-kmp/2.png?raw=true" alt="b)" title="b)" /></p>

<p>很明显，s+1的位置是无效的，但是s+2的位置很有可能是有效的，所以，可以直接向右移动2个位置。</p>

<p>推导中的使用的有用信息可以通过模式自身的比较来预处理计算得到。在这里，可以发现P的最长前缀同时也是<script type="math/tex">P_5</script>的一个真后缀<script type="math/tex">P_3</script>.这些信息可以预先急死俺，用数组next来表示，next[5]=3. 一般化的公式为，在位移s处有q个字符成功匹配，囊而下个有可能有效的位移是<script type="math/tex">s=s-(q-next[q])</script>.</p>

<p>上面提到了<strong>真后缀</strong>,让我们给出定义来。</p>

<p><strong>真前缀</strong>： 字符串中去除1个至多个尾部字符的字符串集合。比如aabac的真前缀为a,aa,aab,aaba.</p>

<p><strong>真后缀</strong>： 字符串中去除1个至多个头部字符的字符串集合。比如aabac的真后缀为c,ac,bac,abac.</p>

<p>好了 ，有了上面的定义，我们就可以简单，最重要的是明白计算next值了：<code>某个位置的next值为，到此位置的字符串产生的真前缀和真后缀</code><strong>并集</strong><code>中的最长元素的长度</code>。</p>

<p>就比如上面的那个例子，模式串为”ababaca”</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">&quot;a&quot;的真前缀和真后缀都为空集，next[0]=0;
</span><span class="line">
</span><span class="line">&quot;ab&quot;的真前缀为[b],真后缀为[a], next[1]=0;
</span><span class="line">
</span><span class="line">&quot;aba&quot;的真前缀为[a,ab],真后缀为[a,ba],next[2]=1;
</span><span class="line">
</span><span class="line">&quot;abab&quot;的真前缀为[a,ab,aba],真后缀为[b,ab,bab],next[3]=2;
</span><span class="line">
</span><span class="line">&quot;ababa&quot;的真前缀为[a,ab,aba,abab],真后缀为[baba,aba,ba,a],next[4]=3;
</span><span class="line">
</span><span class="line">&quot;ababac&quot;的真前缀为[a,ab,aba,abab,ababa],真后缀为[babac,abac,bac,ac,c],next[5]=0;
</span><span class="line">
</span><span class="line">&quot;ababaca&quot;的真前缀为[a,ab,aba,abab,ababa,ababac],真后缀为[babaca,abaca,baca,aca,ca,a],next[5]=1;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-1">如何使用</h4>

<p>见上面的例子吧，很好理解不是。</p>

<p>对了一下是代码。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="kt">void</span> <span class="n">compute_prefix</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">next</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">q</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">q</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="c1">///前q个字符中，前缀字符串集和后缀字符串集中最长的交集元素的长度</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span><span class="p">[</span><span class="n">q</span><span class="p">])</span> <span class="p">)</span>
</span><span class="line">            <span class="n">k</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="c1">/// 请看前面的那个状态转移函数的公式</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="p">)</span>
</span><span class="line">            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="n">next</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="kt">void</span> <span class="n">kmp_match</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">P</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">bool</span> <span class="n">flag</span><span class="o">=</span><span class="kc">false</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">strlen</span><span class="p">(</span><span class="n">P</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
</span><span class="line">    <span class="n">compute_prefix</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">q</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">q</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">P</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">!=</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class="line">            <span class="n">q</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">q</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class="line">            <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">q</span><span class="o">==</span><span class="n">m</span><span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">flag</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span>
</span><span class="line">            <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;math occurs with &quot;</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="o">-</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">            <span class="n">q</span><span class="o">=</span><span class="n">next</span><span class="p">[</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">flag</span><span class="o">==</span><span class="kc">false</span><span class="p">)</span>
</span><span class="line">        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;there is no math!&quot;</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h4 id="section-2">总结</h4>

<p>相对于朴素的匹配算法，这里并不是在匹配失败后直接无脑的外后移一位就可以了，而是利用了模式串本身的信息，<strong>位移的距离=已经匹配的长度-该位置next值</strong>。</p>

<p>希望对你有用。当然要是觉得有问题直接留言好了，一起学吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表排序]]></title>
    <link href="http://aluenkinglee.com/blog/2014/05/14/sort-list/"/>
    <updated>2014-05-14T13:51:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/05/14/sort-list</id>
    <content type="html"><![CDATA[<p>链表不想数组那样是连续的即像数组那样随机访问，只能从前往后遍历。所以排序的方法只能是像插入排序，选择排序，和归并排序。</p>

<p>下面就先说归并排序。</p>

<!-- more -->

<p>简单的数据结构</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ListNode</span> <span class="o">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">val</span><span class="o">;</span>
</span><span class="line">    <span class="n">ListNode</span> <span class="n">next</span><span class="o">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span><span class="line">        <span class="n">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>思想很简单，就是找到链表的中点，然后左右递归排序，最后合并。
详情还是看代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
</pre></td><td class="code"><pre><code class="java"><span class="line">    <span class="cm">/**</span>
</span><span class="line"><span class="cm">     * @param head</span>
</span><span class="line"><span class="cm">     * @return 链表中点</span>
</span><span class="line"><span class="cm">     */</span>
</span><span class="line">    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">middle</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class="line">            <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
</span><span class="line">        <span class="n">ListNode</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class="line">        <span class="n">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">        <span class="k">while</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">pre</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">pre</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">merge</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">leftHead</span><span class="o">,</span> <span class="n">ListNode</span> <span class="n">rightHead</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="c1">// 头部节点，本身没有用处，只是为了让代码更简便</span>
</span><span class="line">        <span class="n">ListNode</span> <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
</span><span class="line">        <span class="n">ListNode</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class="line">        <span class="k">while</span> <span class="o">(</span><span class="n">leftHead</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">rightHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="k">if</span> <span class="o">(</span><span class="n">leftHead</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">rightHead</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">leftHead</span><span class="o">;</span>
</span><span class="line">                <span class="n">leftHead</span> <span class="o">=</span> <span class="n">leftHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class="line">                <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">rightHead</span><span class="o">;</span>
</span><span class="line">                <span class="n">rightHead</span> <span class="o">=</span> <span class="n">rightHead</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">            <span class="o">}</span>
</span><span class="line">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">leftHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">leftHead</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">rightHead</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">cur</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">rightHead</span><span class="o">;</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">
</span><span class="line">    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">sortList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="c1">//单个节点直接返回</span>
</span><span class="line">        <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">            <span class="n">ListNode</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">middle</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
</span><span class="line">            <span class="n">ListNode</span> <span class="n">after</span> <span class="o">=</span> <span class="n">mid</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class="line">            <span class="n">mid</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class="line">            <span class="n">head</span> <span class="o">=</span> <span class="n">sortList</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
</span><span class="line">            <span class="n">after</span> <span class="o">=</span> <span class="n">sortList</span><span class="o">(</span><span class="n">after</span><span class="o">);</span>
</span><span class="line">            <span class="n">head</span> <span class="o">=</span> <span class="n">merge</span><span class="o">(</span><span class="n">head</span><span class="o">,</span> <span class="n">after</span><span class="o">);</span>
</span><span class="line">        <span class="o">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
</span><span class="line">    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>测试样例：边界值
2 1
1 
2 -1 1</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[generative method]]></title>
    <link href="http://aluenkinglee.com/blog/2014/04/30/generative-method/"/>
    <updated>2014-04-30T22:52:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/04/30/generative-method</id>
    <content type="html"><![CDATA[<p>线性回归模型和logistic回归是判别模型，也就是根据特征值来求结果的概率。形式化表
示为<script type="math/tex">p(y|x;\theta)</script>在参数<script type="math/tex">\theta</script>确定的情况下，求解条件概率<script type="math/tex">p(y|x)</script>。
通俗的解释为在给定特征后预测结果出现的概率。</p>

<p>就按照Andrew Ng讲的那样，确定肿瘤是良性的还是恶性的，可以使用判别模型的方法是先
从历史数据中学习到模型，然后通过提取肿瘤的特征来预测出它是良性恶性的概率。</p>

<p>反过来，要是我们先从良性肿瘤学习出良性肿瘤的模型，从恶性肿瘤学习出恶性肿瘤的模型，
然后提取肿瘤的特征，放到良性肿瘤的模型看下概率，在放到恶性肿瘤的模型看下概率，哪个
大是哪个。</p>

<p>形式化表示为求<script type="math/tex">P(X|Y)</script>,x是特征，y是类型即模型。
利用贝叶斯公式发现两个模型的统一性：</p>

<script type="math/tex; mode=display">
p(y|x)=\frac { p(x|y)p(y) }{ p(x) } 
</script>

<p>由于我们关注的是 y 的离散值结果中哪个概率大（比如良性肿瘤和恶性肿瘤哪个概率大），
而并不是关心具体的概率，因此上式改写为：</p>

<script type="math/tex; mode=display">% &lt;![CDATA[

\quad \quad \quad \quad \begin{eqnarray} \max _{ y }{ p(y|x) }  & = & \max _{ y }{ \frac { p(x|y)p(y) }{ p(x) }  }  \\  & = &\max _{ y } p(x|y)p(y) \end{eqnarray}
 %]]&gt;</script>

<table>
  <tbody>
    <tr>
      <td>其中$$p(x</td>
      <td>y)<script type="math/tex">称为后验概率,</script>p(y)$$称为先验概率.</td>
    </tr>
  </tbody>
</table>

<p>由<script type="math/tex">p(x|y)*p(y)=p(x,y)</script>,因此有时称判别模型求的是条件概率，生成模型求的是联
合概率。</p>

<p>常见的判别模型有线性回归、对数回归、线性判别分析、支持向量机、boosting、条件
随机场、神经网络等。</p>

<p>常见的生产模型有隐马尔科夫模型、朴素贝叶斯模型、高斯混合模型、LDA、Restricted 
Boltzmann Machine 等。</p>

<p>上篇博客较为详细地介绍了两个模型</p>

<h3 id="gaussian-discriminant-analysis">高斯判别分析（Gaussian discriminant analysis）</h3>

<h5 id="section">多维正太分布</h5>

<p>多变量正态分布描述的是n维随机变量的分布情况。所以这里的<script type="math/tex">\mu </script>变成了n维随机变量，<script type="math/tex">\sigma </script>也变成了
矩阵<script type="math/tex">\Sigma </script>.记做<script type="math/tex">N(\mu,\Sigma)</script>.假设有 n 个随机变量<script type="math/tex">X_1,X_2,\cdots ,X_n</script>.所以显而易见，<script type="math/tex">\mu </script>的第i个分量是<script type="math/tex">E(X_i),\Sigma_{ii}=Var(X_i),\Sigma_{ij}=Cov(X_i,X_j)</script>.</p>

<p>概率密度函数如下：</p>

<script type="math/tex; mode=display">
p(x;\mu,\Sigma)=\frac { 1 }{ \left( 2\pi  \right) ^{ n/2 }\left| \Sigma  \right| ^{ 1/2 } } exp\left( -\frac { 1 }{ 2 } \left( x-\mu \right)^T \Sigma^{-1}{\left(x-\mu\right)} \right) 
</script>

<h5 id="section-1">模型分析与应用</h5>

<table>
  <tbody>
    <tr>
      <td>如果输入特征x连续型随机变量，那么可以使用高斯判别分析模型来确定$$p(x</td>
      <td>y)$$。模型如下,先以二元分布即伯努利分布来说（因为前面的例子是二元的）:</td>
    </tr>
  </tbody>
</table>

<script type="math/tex; mode=display">
y\sim Bernoulli\left( \phi \right) \\
x|y=0\sim N(\mu_0,\Sigma)\\
x|y=1\sim N(\mu_1,\Sigma)
</script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Discriminative Model Vs. Generative Model]]></title>
    <link href="http://aluenkinglee.com/blog/2014/04/30/discriminative-model-vs-generative-model/"/>
    <updated>2014-04-30T17:17:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/04/30/discriminative-model-vs-generative-model</id>
    <content type="html"><![CDATA[<h2 id="section">判别模型和生成模型分析</h2>

<p>在学习复习ML内容时，中文检索生成模型搜到了该<a href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=248173&amp;do=blog&amp;id=227964">这里</a>本文主要参考该文章，并稍作整理。</p>

<!-- more -->

<p>这两者进行预测的方式不同在于模型的处理上：</p>

<p><strong>生成模型</strong>：无穷样本 ==&gt; 概率密度模型 = 产生模型 ==&gt; 预测</p>

<p><strong>判别模型</strong>：有限样本 ==&gt; 判别函数 = 预测模型 ==&gt; 预测</p>

<p>简单的说，假设<script type="math/tex">x</script>是观察值，<script type="math/tex">y</script>是模型。</p>

<p>如果对先验概率<script type="math/tex">P(x|y)</script>建模，就是<strong>生成模型（Generative modle）</strong>。
其基本思想是首先建立样本的概率密度模型，再利用模型进行推理预测。要求已知样本无穷或尽可能的大。
这种方法一般建立在统计力学和bayes理论的基础之上。</p>

<p>如果对条件概率(后验概率)<script type="math/tex">P(y|x)</script>建模，就是<strong>判别模型（Discrminative modle）</strong>。基本思想是有限样本条件下建立判别函数，不考虑样本的产生模型，直接研究预测模型。代表性理论为统计学习理论。
这两种方法目前交叉较多。</p>

<h3 id="discriminative-model">判别模型Discriminative Model</h3>

<p>又可以称为条件模型，或条件概率模型。估计的是条件概率分布(conditional distribution)，即<script type="math/tex"> p(class|context)</script>。按照上文的记法就是<script type="math/tex">P(y|x)</script>
利用正负例和分类标签，焦点在判别模型的边缘分布。目标函数直接对应于分类准确率。</p>

<h6 id="section-1">主要特点：</h6>

<p>寻找不同类别之间的最优分类面，反映的是异类数据之间的差异。</p>

<h6 id="section-2">优点:</h6>

<ol>
  <li>
    <p>分类边界更灵活，比使用纯概率方法或生产模型得到的更高级。</p>
  </li>
  <li>
    <p>能清晰的分辨出多类或某一类与其他类之间的差异特征</p>
  </li>
  <li>
    <p>在聚类、viewpoint changes, partial occlusion and scale variations中的效果较好</p>
  </li>
  <li>
    <p>适用于较多类别的识别</p>
  </li>
  <li>
    <p>判别模型的性能比生成模型要简单，比较容易学习</p>
  </li>
</ol>

<h6 id="section-3">缺点:</h6>

<ol>
  <li>
    <p>不能反映训练数据本身的特性。能力有限，可以告诉你的是1还是2，但没有办法把整个场景描述出来。</p>
  </li>
  <li>
    <p>Lack elegance of generative: Priors, 结构, 不确定性</p>
  </li>
  <li>
    <p>Alternative notions of penalty functions, regularization, 核函数</p>
  </li>
  <li>
    <p>黑盒操作: 变量间的关系不清楚，不可视</p>
  </li>
</ol>

<p><strong>常见的机器学习方法</strong>：</p>

<ol>
  <li>
    <p>logistic regression</p>
  </li>
  <li>
    <p>支持向量机（SVM）</p>
  </li>
  <li>
    <p>传统的神经网络（traditional neural networks）</p>
  </li>
  <li>
    <p>K近邻，最近邻（Nearest neighbor）</p>
  </li>
  <li>
    <p>Conditional random fields(CRF): 目前最新提出的热门模型，从NLP领域产生的，正在向ASR和CV上发展。</p>
  </li>
</ol>

<h6 id="section-4">主要应用：</h6>

<ol>
  <li>
    <p>图像文本分类</p>
  </li>
  <li>
    <p>生物科学分析</p>
  </li>
  <li>
    <p>时间序列预测</p>
  </li>
</ol>

<h3 id="generative-model">生成模型Generative Model</h3>

<table>
  <tbody>
    <tr>
      <td>估计的是联合概率分布（joint probability distribution），$$p(class, context)=p(class</td>
      <td>context)*p(context)<script type="math/tex">,换用之前的描述就是</script>p(y, x)=p(y</td>
      <td>x)*p(x)$$.</td>
    </tr>
  </tbody>
</table>

<p>用于随机生成的观察值建模，特别是在给定某些隐藏参数情况下。在机器学习中，或用于直接对数据建模（用概率密度函数对观察到的draw建模），或作为生成条件概率密度函数的中间步骤。通过使用<strong>贝叶斯定律</strong>可以从生成模型中得到条件分布。</p>

<p>如果观察到的数据是完全由生成模型所生成的，那么就可以拟合生成模型的参数，从而仅可能的增加数据相似度。但观测数据往往完全从生成模型得到，所以比较准确的方式是直接对条件密度函数建模，即使用分类或回归分析。</p>

<h6 id="section-5">主要特点:</h6>

<ol>
  <li>
    <p>一般主要是对<strong>后验概率</strong>建模，从统计的角度表示数据的分布情况，能够反映同类数据本身的相似度</p>
  </li>
  <li>
    <p>只关注自己的inclass本身（即点左下角区域内的概率），不关心到底判别边界在哪</p>
  </li>
</ol>

<h6 id="section-6">优点:</h6>

<ol>
  <li>
    <p>模型可以通过增量学习得到（同意！）</p>
  </li>
  <li>
    <p>研究单类问题比判别模型灵活性强(怀疑？)</p>
  </li>
  <li>
    <p>能用于数据不完整（missing data）情况(怀疑？)</p>
  </li>
  <li>
    <p>实际上带的信息要比判别模型丰富（多太多！同意！）</p>
  </li>
  <li>
    <p>prior knowledge can be easily taken into account（同意！）</p>
  </li>
  <li>
    <p>modular construction of composed solutions to complex problems</p>
  </li>
  <li>
    <p>robust to partial occlusion and viewpoint changes</p>
  </li>
  <li>
    <p>can tolerate significant intra-class variation of object appearance</p>
  </li>
</ol>

<h6 id="section-7">缺点:</h6>

<ol>
  <li>学习和计算过程比较复杂</li>
</ol>

<p><strong>常见的机器学习方法</strong>：</p>

<ol>
  <li>
    <p><strong>Gaussians判别分析</strong></p>
  </li>
  <li>
    <p>** Naive Bayes**， Bayesian networks</p>
  </li>
  <li>
    <p>Mixtures of Gaussians（混合高斯模型）</p>
  </li>
  <li>
    <p>HMMs，Markov random fields</p>
  </li>
  <li>
    <p>Sigmoidal belief networks</p>
  </li>
</ol>

<h4 id="section-8">两者之间的关系</h4>

<p><strong>由生成模型可以得到判别模型，但由判别模型得不到生成模型。</strong></p>

<blockquote>
  <blockquote>
    <p>参考</p>
  </blockquote>
</blockquote>

<p>http://prfans.com/forum/viewthread.php?tid=80</p>

<p>http://hi.baidu.com/cat_ng/blog/item/5e59c3cea730270593457e1d.html</p>

<p>http://en.wikipedia.org/wiki/Generative_model</p>

<p>http://blog.csdn.net/yangleecool/archive/2009/04/05/4051029.aspx</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[dynamic programming]]></title>
    <link href="http://aluenkinglee.com/blog/2014/04/29/dynamic-programming/"/>
    <updated>2014-04-29T19:34:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/04/29/dynamic-programming</id>
    <content type="html"><![CDATA[<p>好几年了，没有特意去做与ACM相关的算法题了，时至今日，也确实忘得差不多了，不过，现在也到了该拾起来的时候了。</p>

<h5 id="section">动态规划</h5>
<!--more -->

<p>动态规划（Dynamic Programming）是用来解决最优化问题的最常用手段,说起定义，网上浩瀚如烟，有很多类型，比如：</p>

<ul>
  <li>
    <p>背包问题：0-1背包，完全背包，硬币问题，装箱子问题等。</p>
  </li>
  <li>
    <p>最短路径问题：网络流等。</p>
  </li>
  <li>
    <p>树形动规：最优查找树。</p>
  </li>
</ul>

<p>等等等等，严格的划分问题类型没有意义，关键是分析问题的本质：阶段，状态，状态转移，全局最优。</p>

<h5 id="section-1">一些术语</h5>

<p>首先，先介绍下相关的概念，在结合具体的，例子加深感性和理性上的认识。</p>

<p>动态规划问题的一个通用特点是具备<code>最优子结构</code>和<code>重叠子问题</code>。当前子问题的解将由上一次子问题的解推出。每一个问题对应一个它的<strong>状态</strong>。<code>重叠子问题</code>的意思，某些问题的计算是有重叠的，若该计算结果记录下来，之后其他子问题遇到重叠的直接查表就可以了，避免重复计算。最优子结构则是我们的全局问题可以分解，按照<strong>阶段</strong>来分解。从而规约到最简的问题。说到这，是不是想到了分治法？，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次（把它们记录下来嘛！）。而且另外一个思想是，动规有明显的阶段的概念，而分治只是把问题分成不重复的规模较小的没有阶段概念的小问题。</p>

<p><strong>基本结构</strong></p>

<p>多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法。</p>

<p><strong>什么是动态规划，我们要如何描述它?</strong></p>

<p>先来看下形式化的描述的吧，在结合例子描述它。</p>

<script type="math/tex; mode=display">
f\left( S \right) =\underset { d\in D\left( S \right)  }{ opt } \left\{ cos\left( d\vert S \right) \quad \circ \quad f\left( T\left( d|S \right)  \right)  \right\} 
</script>

<p>其中，<code>S</code>是代指<code>state</code>，就是状态空间的一个state，动态规划解决的问题是按照状态和该状态可以选择的决策来解决问题的。确切的来说，<code>S</code>代表的就是从开始到当前决策的问题状态；</p>

<p><code>d</code>代指<code>decision</code>，是一个从<code>S</code>状态所决定的决策空间中<script type="math/tex">D\left( S \right) </script>做出的决策，不同状态决定的决策空间有可能不同。举例说明，对于硬币问题来讲，假设每个硬币的个数都是无限的，那么对于任何一个状态（目前手里有多少钱），接下来做的决策个数都是一样的，都是从固定的那几枚硬币中挑选；对于不可重复选择的问题，比如拿球，有红黑黄3个球，每个球的权值不同，求一个选球次序使之最优，这下好了，每个阶段的决策空间都是不同的，对于状态1，有红，黑，黄三种状态，接下来，就只能选剩下的球里面的了。所以决策空间会因问题而变化的。还有TSP旅行者问题，在每个节点所对应的状态时从起点到当前状态的最短距离，接下来的选择，得看该节点（状态）的出度是谁了。<strong>所以说，决策依赖当前的状态</strong>。</p>

<p><script type="math/tex">D\left( S \right) </script>是决策空间(decision space)，代表从当前状态转到另一个状态时，或者从另一个状态转到当前状态可以选择的决策<code>d</code>的结合。（之所以使用或者是说了两种考虑的方式）</p>

<p><code>f</code>是指目标函数(target function)，一个关于状态的函数，往往代表从初始状态到达状态<code>S</code>所做的所有决策中的最优利益（不是最大就是最小）。</p>

<p><script type="math/tex">cos\left( d\vert S \right) </script>可以叫做成本函数(cost function)，很好理解，就是在状态<code>S</code>下，做出选择<code>d</code>的成本，成本函数和目标函数不同，因为它不需要依赖上下文条件，只需一步计算就可以搞定。</p>

<p><script type="math/tex">cos\left( d\vert S \right) </script>代表的是转移函数(transfer function)，就是指从S做一个决策到达另外一个状态<script type="math/tex">S'</script>.</p>

<p><script type="math/tex">\circ</script>是一个二元操作符，多数是加法或者乘法或者是最大值要不就是最小值。</p>

<p>除此之外，还需要边界条件。</p>

<p>最后来看个最简单的例子。</p>

<h5 id="section-2">例子</h5>

<p>如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？有多少种兑换方法？</p>

<p>思路：这个比较简单，状态就是硬币的价值，有多少钱，决策空间是固定的<script type="math/tex">D(S)={1,3,5}</script></p>

<p>用<script type="math/tex">f(i)</script>代表凑够i元，得用最少多少硬币。成本函数也是固定的，为1。</p>

<script type="math/tex; mode=display">
f(i)=\underset { d\in D\left( {1,3,5} \right)  }{min}{1+f(i-d)},i!=0
</script>

<p>当然了<script type="math/tex">i==0</script>时，f(0)=0.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">f(11)=min{1+f(11-1),1+f(11-3),1+f(11-5)};
</span><span class="line">f(10)=min{1+f(10-1),1+f(10-3),1+f(10-5)};
</span><span class="line">f(9)=min{1+f(9-1),1+f(9-3),1+f(9-5)};
</span><span class="line">f(8)=min{1+f(8-1),1+f(8-3),1+f(8-5)};
</span><span class="line">f(7)=min{1+f(7-1),1+f(7-3),1+f(7-5)};
</span><span class="line">f(6)=min{1+f(6-1),1+f(6-3),1+f(6-5)};
</span><span class="line">f(5)=min{1+f(5-1),1+f(5-3),1+f(5-5)};
</span><span class="line">f(4)=min{1+f(4-1),1+f(4-3) )};
</span><span class="line">f(3)=min{1+f(3-1),1+f(3-3) )};
</span><span class="line">f(2)=min{1+f(2-1)};
</span><span class="line">f(1)=min{1+f(1-1)};
</span><span class="line">f(0)已知=0；
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>所以：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">f(1)=min{1+f(1-1)}=1；
</span><span class="line">f(2)=min{1+f(2-1)}=2；
</span><span class="line">f(3)=min{1+f(3-1),1+f(3-3) )}=min{3,1}=1;
</span><span class="line">f(4)=min{1+f(4-1),1+f(4-3) )}=min{2,2}=2;
</span><span class="line">f(5)=min{1+f(5-1),1+f(5-3),1+f(5-5)}=min{3,3,1}=1;
</span><span class="line">f(6)=min{1+f(6-1),1+f(6-3),1+f(6-5)}=min{2,2,2}=2;
</span><span class="line">f(7)=min{1+f(7-1),1+f(7-3),1+f(7-5)}=min{3,3,3}=3;
</span><span class="line">f(8)=min{1+f(8-1),1+f(8-3),1+f(8-5)}=min{4,2,2}=2;
</span><span class="line">f(9)=min{1+f(9-1),1+f(9-3),1+f(9-5)}=min{3,3,3}=3;
</span><span class="line">f(10)=min{1+f(10-1),1+f(10-3),1+f(10-5)}=min{4,4,2}=2;
</span><span class="line">f(11)=min{1+f(11-1),1+f(11-3),1+f(11-5)}=min{3,3,3}=3;
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>从我们的计算过程来看，求解既可以从前往后也可以从后往前。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[some commen list problems in the interview]]></title>
    <link href="http://aluenkinglee.com/blog/2014/04/28/some-commen-list-problems-in-the-interview/"/>
    <updated>2014-04-28T21:54:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/04/28/some-commen-list-problems-in-the-interview</id>
    <content type="html"><![CDATA[<p>链表是最基本的数据结构，面试官也常常用链表来考察面试者的基本能力，而且链表相关的操作相对而言比较简单，也适合考察写代码的能力。链表的操作也离不开指针，指针又很容易导致出错。综合多方面的原因，链表题目在面试中占据着很重要的地位。本文对链表相关的面试题做了较为全面的整理，希望能对找工作的同学有所帮助。
链表结点声明如下：</p>

<!-- more -->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">///=======链表</span>
</span><span class="line"><span class="k">struct</span> <span class="n">ListNode</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="section">求单链表中结点的个数</h5>

<p>最最基本的，应该能够迅速写出正确的代码，注意检查链表是否为空。时间复杂度为O（n）。参考代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">/// 求单链表中结点的个数</span>
</span><span class="line"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">getListLenght</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">    <span class="k">for</span><span class="p">(;</span> <span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">len</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="section-1">将单链表反转</h5>

<p>从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）。参考代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">/// 将单链表反转</span>
</span><span class="line"><span class="n">ListNode</span> <span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span> <span class="n">head</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">/// 边界</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">    <span class="c1">/// 反转后的新链表头指针，初始为NULL</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">rHead</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">temp</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">temp</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span><span class="line">        <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="c1">/// 将废弃结点摘下，插入新链表的最前端</span>
</span><span class="line">        <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">rHead</span><span class="p">;</span>
</span><span class="line">        <span class="n">rHead</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">rHead</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="kk--0">查找单链表中的倒数第K个结点（k &gt; 0）</h5>

<p>主要思路就是使用两个指针，先让前面的指针走到正向第k个结点，这样前后两个指针的距离差
是k - 1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指结点就是倒数第k个结点。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">///  查找单链表中的倒数第K个结点（k &gt; 0）</span>
</span><span class="line"><span class="n">ListNode</span> <span class="o">*</span> <span class="n">getRKthNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="c1">/// 这里k的计数是从1开始的，若k为0或链表为空返回NULL</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">ahead</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">behind</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">for</span><span class="p">(;</span> <span class="n">ahead</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">;</span> <span class="o">--</span><span class="n">k</span><span class="p">)</span>   <span class="c1">/// 遍历完前k个节点</span>
</span><span class="line">        <span class="n">ahead</span> <span class="o">=</span> <span class="n">ahead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="p">)</span>            <span class="c1">/// 结点个数小于k，返回NULL</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">ahead</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>    <span class="c1">/// 前后两个指针一起向前走，直到前面的指针指向NULL</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">ahead</span> <span class="o">=</span> <span class="n">ahead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">behind</span> <span class="o">=</span> <span class="n">behind</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">behind</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="section-2">查找单链表的中间结点</h5>

<p>也是设置两个指针，只不过这里是，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度O（n）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">///  查找单链表的中间结点</span>
</span><span class="line"><span class="c1">///  获取单链表中间结点，若链表长度为n(n&gt;0)，则返回第n/2+1个结点</span>
</span><span class="line"><span class="n">ListNode</span> <span class="o">*</span> <span class="n">getMidNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span> <span class="n">head</span> <span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">/// 边界值处理，空或者只有一个节点</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">ahead</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">behind</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">/// 注意判断条件</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">ahead</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>    <span class="c1">/// 前面指针每次走两步，直到指向最后一个结点，后面指针每次走一步</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">ahead</span> <span class="o">=</span> <span class="n">ahead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">behind</span> <span class="o">=</span> <span class="n">behind</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="c1">/// 注意判断条件</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">ahead</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">            <span class="n">ahead</span> <span class="o">=</span> <span class="n">ahead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="k">return</span> <span class="n">behind</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="section-3">从尾到头打印单链表</h5>

<p>顺序颠倒，使用栈。系统栈或者自己写栈用。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">/// 逆序打印</span>
</span><span class="line"><span class="kt">void</span> <span class="n">RPrintList2</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">stack</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span> <span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">tmp</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class="line">        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">tmp</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span><span class="line">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class="line">        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="kt">void</span> <span class="n">RPrintList3</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span><span class="p">;</span>
</span><span class="line">    <span class="n">RPrintList3</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
</span><span class="line">    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="phead1-phead2-">已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</h5>

<p>类似归并排序</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">/// 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</span>
</span><span class="line"><span class="c1">/// 会改变原有链表结构，妥妥的</span>
</span><span class="line"><span class="n">ListNode</span> <span class="o">*</span> <span class="n">MergeSortedList</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span> <span class="n">head1</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span> <span class="n">head2</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">head2</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">head1</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">mergeHead</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head1</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">mergeHead</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
</span><span class="line">        <span class="n">head1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">mergeHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">/// 注意语句顺序，防止head1变成悬空节点</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">mergeHead</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
</span><span class="line">        <span class="n">head2</span> <span class="o">=</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">mergeHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">/// 注意语句顺序，防止head2变成悬空节点</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">temp</span> <span class="o">=</span> <span class="n">mergeHead</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">head1</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">head2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">if</span><span class="p">(</span><span class="n">head1</span><span class="o">-&gt;</span><span class="n">data</span><span class="o">&gt;</span><span class="n">head2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
</span><span class="line">            <span class="n">head1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">            <span class="n">temp</span><span class="o">=</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">else</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
</span><span class="line">            <span class="n">head2</span> <span class="o">=</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">            <span class="n">temp</span><span class="o">=</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">            <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head1</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head2</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="n">mergeHead</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>递归版本</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">/// 已知两个单链表pHead1 和pHead2 各自有序，把它们合并成一个链表依然有序</span>
</span><span class="line"><span class="n">ListNode</span> <span class="o">*</span> <span class="n">MergeSortedList2</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span> <span class="n">head1</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span> <span class="n">head2</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">head2</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="n">head1</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">mergeHead</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head1</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">mergeHead</span> <span class="o">=</span> <span class="n">head1</span><span class="p">;</span>
</span><span class="line">        <span class="n">head1</span> <span class="o">=</span> <span class="n">head1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">mergeHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">MergeSortedList2</span><span class="p">(</span><span class="n">head1</span><span class="p">,</span><span class="n">head2</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">mergeHead</span> <span class="o">=</span> <span class="n">head2</span><span class="p">;</span>
</span><span class="line">        <span class="n">head2</span> <span class="o">=</span> <span class="n">head2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">mergeHead</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">MergeSortedList2</span><span class="p">(</span><span class="n">head1</span><span class="p">,</span><span class="n">head2</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">mergeHead</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="section-4">判断两个单链表是否相交</h5>

<p>如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。
也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住
最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比
较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指
针保存最后一个节点地址，空间复杂度为O(1)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="kt">bool</span> <span class="n">isIntersected</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span> <span class="n">head1</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span> <span class="n">head2</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head1</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail1</span><span class="o">=</span><span class="n">head1</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail2</span><span class="o">=</span><span class="n">head2</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">tail1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="n">tail1</span> <span class="o">=</span> <span class="n">tail1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">tail2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="n">tail2</span> <span class="o">=</span> <span class="n">tail2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="c1">///若相交，尾节点可定相同</span>
</span><span class="line">    <span class="k">return</span> <span class="p">(</span><span class="n">tail1</span> <span class="o">==</span> <span class="n">tail2</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="section-5">求两个单链表相交的第一个节点</h5>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="n">ListNode</span><span class="o">*</span> <span class="n">findFirstIntersectedNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span> <span class="n">head1</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span> <span class="n">head2</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">/// 边界值检查</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">head1</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail1</span><span class="o">=</span><span class="n">head1</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">tail2</span><span class="o">=</span><span class="n">head2</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">len1</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">len2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">tail1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">tail1</span> <span class="o">=</span> <span class="n">tail1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">len1</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">tail2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">tail2</span> <span class="o">=</span> <span class="n">tail2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">len2</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">///若相交，尾节点肯定相同</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">tail1</span> <span class="o">!=</span> <span class="n">tail2</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">node1</span><span class="o">=</span><span class="n">head1</span><span class="p">;</span>
</span><span class="line">    <span class="n">ListNode</span><span class="o">*</span> <span class="n">node2</span><span class="o">=</span><span class="n">head2</span><span class="p">;</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="c1">/// 找到两个链表等长的位置。</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">len1</span><span class="o">&gt;</span><span class="n">len2</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">k</span><span class="o">=</span><span class="n">len1</span><span class="o">-</span><span class="n">len2</span><span class="p">;</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">            <span class="n">node1</span><span class="o">=</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">else</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">k</span><span class="o">=</span><span class="n">len2</span><span class="o">-</span><span class="n">len1</span><span class="p">;</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">k</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">            <span class="n">node2</span><span class="o">=</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">/// 两个链表未相交之前，节点肯定不同</span>
</span><span class="line">    <span class="k">while</span><span class="p">(</span><span class="n">node1</span><span class="o">!=</span><span class="n">node2</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">node1</span><span class="o">=</span><span class="n">node1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">node2</span><span class="o">=</span><span class="n">node2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">node1</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h5 id="head--node-o1-node">给出一单链表头指针 head 和一节点指针 node ，O(1)时间复杂度删除节点 node</h5>

<p>对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是O(1)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="kt">void</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span> <span class="n">node</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="c1">/// 边界值</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">        <span class="k">return</span> <span class="p">;</span>
</span><span class="line">    <span class="k">if</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="c1">/// 把后面的节点值复制到本位置</span>
</span><span class="line">        <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
</span><span class="line">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">/// 删除的是最后一个节点，只能用遍历法</span>
</span><span class="line">        <span class="n">ListNode</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="n">node</span><span class="p">)</span>
</span><span class="line">            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[特征选择-信息增益算法]]></title>
    <link href="http://aluenkinglee.com/blog/2014/04/21/feature-selection--infomation-gain/"/>
    <updated>2014-04-21T15:41:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/04/21/feature-selection&#8211;infomation-gain</id>
    <content type="html"><![CDATA[<p><strong>信息增益</strong>：特征 $A$ 对于训练数据集$D$的信息增益 $g\left( D,A \right)$,定义为集合 $D$ 的经验熵 $H\left( D \right)$ 与特征 $A$ 在给定条件下 $D$ 
的经验条件熵c之差。
<!--more-->
$$
g\left( D,A \right) =H\left( D \right) -H\left( { D }|{ A } \right) 
$$</p>

<p>给定训练数据集$D$和特征$A$，经验熵$H(D)$表示对数据集$D$进行分类的不确定性，
而经验条件熵$H\left( { D }|{ A } \right)$表示在特征$A$给定条件下对数据集$D$分类的的不确定性。他们的差
就是<code>信息增益</code>。表示由于特征$A$而使得对数据集$D$的分类不确定性减少的程度。
显然，对于数据集$D$而言，信息增益依赖特征，不同的特征具有不同的信息增益，信息增益大的特征具有更强的分类能力。</p>

<p>所以算法选择特征的准则就是：对于训练数据集$D$，计算其每个特征的信息增益，并比较他们的大小，选在信息增益最大的特征。</p>

<p>设训练数据集为<script type="math/tex">\left\vert  D  \right\vert </script>表示样本大小，在我们这里就有42个实例。设有$K$个类<script type="math/tex">{C}_{k}</script>。
令<script type="math/tex">\left\vert {C}_{k}  \right\vert</script>为属于类k的个数，即<script type="math/tex">\sum_{k=1}^{K}{\left|{C}_{k} \right|}=\left|D \right|</script>
设特征A有n个不同的取值， <script type="math/tex">a_1, \ldots, a_n</script>，根据特征<script type="math/tex">A</script>的取值将<script type="math/tex">D</script>划分为n个子集，<script type="math/tex">D_1,D_2,\ldots,D_n</script>,<script type="math/tex">\left\vert D_i \right\vert</script>
为<script type="math/tex">D_i</script>的样本个数，<script type="math/tex">\sum_{i=1}^{n}\left\vert D_i \right\vert = \left\vert D \right\vert</script>.记子集<script type="math/tex">D_i</script>中属于类<script type="math/tex">C_k</script>的样本的集合为<script type="math/tex">D_ik</script>,即
<script type="math/tex">D_ik=D_i \cap C_k</script>,<script type="math/tex">|D_ik|</script>为<script type="math/tex">D_ik</script>的样本个数。于是信息增益算法如下：</p>

<p><strong>信息增益算法</strong></p>

<p>输入：训练集D和特征A</p>

<p>输出：特征A对特征集D的信息增益<script type="math/tex">g(D,A)</script></p>

<p>1.计算数据集<script type="math/tex">D</script>的经验熵<script type="math/tex">H(D)</script></p>

<script type="math/tex; mode=display">
H(D)=-\sum_{k=1}^{K}{\frac{\vert C_k \vert}{|D|}}\log_{2}{\frac{\vert C_k \vert}{|D|}}
</script>

<table>
  <tbody>
    <tr>
      <td>2.计算特征<script type="math/tex">A</script>对数据集<script type="math/tex">D</script>的经验条件熵H(D</td>
      <td>A)</td>
    </tr>
  </tbody>
</table>

<script type="math/tex; mode=display">
H(D|A)=\sum_{i=1}^{n}{\frac{|D_i|}{|D|}}H(D_i)=-\sum_{i=1}^{n}{\frac{\vert D_i \vert}{|D|}} \sum_{k=1}^{K}{\frac{\vert D_{ik} \vert}{|D_i|}}\log_{2}{\frac{\vert D_{ik} \vert}{|D_i|}}
</script>

<p>3.计算信息增益</p>

<script type="math/tex; mode=display">
g\left( D,A \right) =H\left( D \right) -H\left( { D }|{ A } \right) 
</script>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[a scratch of feature selection in traffic classification]]></title>
    <link href="http://aluenkinglee.com/blog/2014/04/20/a-scratch-of-feature-selection-in-traffic-classification/"/>
    <updated>2014-04-20T21:02:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/04/20/a-scratch-of-feature-selection-in-traffic-classification</id>
    <content type="html"><![CDATA[<p>特征选取在减轻识别流量监测方面起着很重要的作用。该方法可以显著提高计算流量分类的性能。但是，大部分的特征不能应用在实时在线的流量分类中（有些特征只能在获取完整个流量才能得到，比如传输的数据大小，流的传输时长等）。所以在抉择分类的时候，需要一个优化过的特征集合在更短的时间内完成流量的分类。另外一种方案就是使用新型的网络架构如SDN/OpenFlow在目前已有的特征选择方法中，Chi-squared, Fuzzy-rough and Consistency-based的特征选择方法最适合P2P流量选择（那现在的手机端流量分析怎么样？）这些算法在使用ML进行在线P2P检测时会给出较好的特征子集。
<!--more-->
特征选取是寻找一个最小特征子集，可以快速有效的识别出实例的类别。如果利用一个特征进行分类聚类的结果与不使用它的结果没有很大的差别，则称整个特征时没有分类能力的。使用这些具备分类，聚类能力的特征，在分类的准确性和计算性能上都会得到提升。[1]主要研究的是在线流量分类中的流特征问题。然后考虑精度和性能的因素，选取了3中能够应用到P2P流量中的特征选择方法。</p>

<p>[1]实现的主要方法是使用了几个特征选择算法来提出在线的流量特征，使用J48算法作为分类器。</p>

<p>特征规模大小与分类器的效率和准确率息息相关，最优的特征集合可以减少分类器的建模和检测时间，从而提升分类器的性能[5]。主流的分类器有CSF, CON, Filter-Sub, Fuzzy-rough, Symmetrical-Uncert, Chi-squared,Info Gain, Relief, Principal and Latent-semantic。作者使用的Chi-squared, Consistency and fuzzy-rough算法，相关文献可以在论文[1]中找到。</p>

<h2 id="section">在线特征提取</h2>

<p>尽管Moore提出了248中流量特征，这些特征源自于同一个流中的报头信息。实际应用中的确不能全部都用到。具体操作是对现有的特征集使用那十个特征选择方法，分别选出各自的特征子集，然后应用到SVM分类器中，判别的准则为建模时间(训练时间)和准确率。然后合并准确率最高的前3个特征集合的并集作为最优特征子集。然后在分出那些特征可以在线获取（SOF-selection of features），他们作为分类器的输入-报文的特征向量。</p>

<p>核心思想是使用监督方法对有标记的数据集进行分类时，对特征集合进行规约，减少特征集的大小。</p>

<h6 id="section-1">使用信息熵增益算法对特征进行降纬</h6>

<p>实验前,<a href="http://www.aluenkinglee.com/blog/2014/04/21/feature-selection--infomation-gain/">信息熵增益算法</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">Instances:    42
</span><span class="line">Attributes:   35
</span><span class="line">              sip
</span><span class="line">              sport
</span><span class="line">              dip
</span><span class="line">              dport
</span><span class="line">              protocal
</span><span class="line">              interval1
</span><span class="line">              interval2
</span><span class="line">              interval3
</span><span class="line">              interval4
</span><span class="line">              interval5
</span><span class="line">              interval6
</span><span class="line">              interval7
</span><span class="line">              interval8
</span><span class="line">              interval9
</span><span class="line">              packet_len1
</span><span class="line">              packet_len2
</span><span class="line">              packet_len3
</span><span class="line">              packet_len4
</span><span class="line">              packet_len5
</span><span class="line">              packet_len6
</span><span class="line">              packet_len7
</span><span class="line">              packet_len8
</span><span class="line">              packet_len9
</span><span class="line">              packet_len10
</span><span class="line">              payload_len1
</span><span class="line">              payload_len2
</span><span class="line">              payload_len3
</span><span class="line">              payload_len4
</span><span class="line">              payload_len5
</span><span class="line">              payload_len6
</span><span class="line">              payload_len7
</span><span class="line">              payload_len8
</span><span class="line">              payload_len9
</span><span class="line">              payload_len10
</span><span class="line">              cluster
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>得到的属性的排序是</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">Ranked attributes:
</span><span class="line"> 1.944968503161257472   12 interval7
</span><span class="line"> 1.79590506127720192    22 packet_len8
</span><span class="line"> 1.789000161744105216    9 interval4
</span><span class="line"> 1.485875203840541952   32 payload_len8
</span><span class="line"> 1.476115354039271936   24 packet_len10
</span><span class="line"> 1.474554148784290048   19 packet_len5
</span><span class="line"> 1.433523944277332992   11 interval6
</span><span class="line"> 1.4172094615274624     20 packet_len6
</span><span class="line"> 1.40428856745235968     6 interval1
</span><span class="line"> 1.326924790992714496   34 payload_len10
</span><span class="line"> 1.181689898847241984   18 packet_len4
</span><span class="line"> 1.105237515513706624   23 packet_len9
</span><span class="line"> 1.009802257207393664   28 payload_len4
</span><span class="line"> 1.000000000000000896   31 payload_len7
</span><span class="line"> 1.000000000000000896   30 payload_len6
</span><span class="line"> 0.993447238380203776   21 packet_len7
</span><span class="line"> 0.868563607479333888    3 dip
</span><span class="line"> 0.832352013234566144   14 interval9
</span><span class="line"> 0.829607103088203904   29 payload_len5
</span><span class="line"> 0.781988055469156096   17 packet_len3
</span><span class="line"> 0.781988055469156096   16 packet_len2
</span><span class="line"> 0.737113917996471168   10 interval5
</span><span class="line"> 0.544053730963280448    2 sport
</span><span class="line"> 0                      27 payload_len3
</span><span class="line"> 0                       5 protocal
</span><span class="line"> 0                       1 sip
</span><span class="line"> 0                       4 dport
</span><span class="line"> 0                      33 payload_len9
</span><span class="line"> 0                      25 payload_len1
</span><span class="line"> 0                      15 packet_len1
</span><span class="line"> 0                      13 interval8
</span><span class="line"> 0                       7 interval2
</span><span class="line"> 0                      26 payload_len2
</span><span class="line"> 0                       8 interval3
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>所以对于属性payload_len3，protocal，sip，dport，payload_len9，payload_len1，payload_len2，packet_len1，interval8，interval2，interval3这十一个属性都可以去掉。
降维之后的属性集合大小为23.</p>

<p>降维之后的聚类结果</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-04-20-a-scratch-of-feature-selection-in-traffic-classification/reduction2.png?raw=true" alt="降维之后的聚类结果" title="降维之后的聚类结果" /></p>

<p>降维之前的聚类结果</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-04-20-a-scratch-of-feature-selection-in-traffic-classification/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E8%B7%9D%E7%A6%BB.png?raw=true" alt="降维之前的聚类结果" title="降维之前的聚类结果" /></p>

<p>效果非常吻合。</p>

<h6 id="pca">使用PCA对特征集规约</h6>

<p>这个使用weka的来做的，做出来之后有12个特征（都是原有特征的线性组合）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">Attributes:   12
</span><span class="line">              0.333payload_len7+0.332packet_len7-0.307dip+0.295payload_len6+0.293packet_len6...
</span><span class="line">              0.399packet_len8+0.398payload_len8-0.269payload_len5-0.268packet_len5+0.261interval5...
</span><span class="line">              0.399interval4+0.309interval1-0.308packet_len10-0.274packet_len9-0.272payload_len9...
</span><span class="line">              -0.366payload_len9-0.366packet_len9-0.349packet_len5-0.347payload_len5-0.288interval1...
</span><span class="line">              -0.357interval3+0.351packet_len7+0.348payload_len7-0.324interval5+0.313interval7...
</span><span class="line">              0.454interval6-0.424interval5-0.401interval1+0.262interval9+0.256packet_len4...
</span><span class="line">              -0.402interval7-0.388payload_len6-0.387packet_len6-0.357interval8-0.26sport...
</span><span class="line">              -0.597interval9+0.443packet_len10-0.427packet_len2-0.239packet_len3-0.209packet_len6...
</span><span class="line">              0.865interval2+0.178interval3+0.168packet_len10+0.149packet_len4-0.146payload_len9...
</span><span class="line">              -0.751sport+0.346interval3+0.286dip+0.216interval7-0.178packet_len2...
</span><span class="line">              -0.434interval3+0.425interval2+0.315payload_len9+0.312packet_len9-0.311sport...
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>降维之后的聚类结果</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-04-20-a-scratch-of-feature-selection-in-traffic-classification/reduction1.png?raw=true" alt="降维之后的聚类结果" title="降维之后的聚类结果" /></p>

<p>分析，由于降维特征减少太多，走势已经不太吻合。</p>

<h6 id="section-2">卡方分布提取特征算法</h6>

<p>对于这个算法，这里只给出特征选取的结果</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
</pre></td><td class="code"><pre><code class="text"><span class="line">Ranked attributes:
</span><span class="line">157.0864   12 interval7
</span><span class="line">145.6184   22 packet_len8
</span><span class="line">130.1739   20 packet_len6
</span><span class="line">123.7833    6 interval1
</span><span class="line">123.0833    9 interval4
</span><span class="line">118.16     32 payload_len8
</span><span class="line">108.7528   34 payload_len10
</span><span class="line">108.5061   24 packet_len10
</span><span class="line">103.1333   18 packet_len4
</span><span class="line"> 92.3818   11 interval6
</span><span class="line"> 85.5423   23 packet_len9
</span><span class="line"> 81.0409   19 packet_len5
</span><span class="line"> 61.9733   28 payload_len4
</span><span class="line"> 42        31 payload_len7
</span><span class="line"> 42        29 payload_len5
</span><span class="line"> 42        30 payload_len6
</span><span class="line"> 42        21 packet_len7
</span><span class="line"> 39.4135   16 packet_len2
</span><span class="line"> 39.4135   17 packet_len3
</span><span class="line"> 38.4      14 interval9
</span><span class="line"> 37.9167    2 sport
</span><span class="line"> 36.9542    3 dip
</span><span class="line"> 33.9      10 interval5
</span><span class="line">  0         5 protocal
</span><span class="line">  0        33 payload_len9
</span><span class="line">  0         4 dport
</span><span class="line">  0         1 sip
</span><span class="line">  0        25 payload_len1
</span><span class="line">  0        15 packet_len1
</span><span class="line">  0        13 interval8
</span><span class="line">  0         8 interval3
</span><span class="line">  0         7 interval2
</span><span class="line">  0        26 payload_len2
</span><span class="line">  0        27 payload_len3
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>被取消的特征同样是那11个特征，只是排序结果不一样了。
所以理所当然kmeans实验室一致的。
Kmeans实验和实验1一样</p>

<p>最终选取的特征集合为23个</p>

<h4 id="section-3">参考</h4>

<p>[1]. Jamil, H.A., et al., Selection of On-line Features for Peer-to-Peer Network Traffic Classification, in Recent Advances in Intelligent Informatics. 2014, Springer. p. 379-390.</p>

<p>[2]. Zhen, L. and L. Qiong, A new feature selection method for internet traffic classification using ml. Physics Procedia, 2012. 33: p. 1338-1345.</p>

<p>[3]. Moore, A.W. and D. Zuev. Internet traffic classification using bayesian analysis techniques. in ACM SIGMETRICS Performance Evaluation Review. 2005: ACM.</p>

<p>[4]. Dash, M. and P.W. Koot, Feature selection for clustering, in Encyclopedia of database systems. 2009, Springer. p. 1119-1125.</p>

<p>[5]. 统计学习方法。李航</p>

<p>[6]. Mitra, P., C.A. Murthy and S.K. Pal, Unsupervised feature selection using feature similarity. IEEE transactions on pattern analysis and machine intelligence, 2002. 24(3): p. 301-312.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“奇异”的内存覆盖]]></title>
    <link href="http://aluenkinglee.com/blog/2014/03/04/qi-yi-de-nei-cun-fu-gai/"/>
    <updated>2014-03-04T22:01:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/03/04/qi-yi-de-nei-cun-fu-gai</id>
    <content type="html"><![CDATA[<p>犯了一个愚蠢的问题，让我碰到了这么个内容错误的bug</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
</pre></td><td class="code"><pre><code class="bash"><span class="line">*** glibc detected *** ./main: free<span class="o">()</span>: invalid next size <span class="o">(</span>fast<span class="o">)</span>: 0x0000000001dd8590 ***
</span><span class="line"><span class="o">=======</span> Backtrace: <span class="o">=========</span>
</span><span class="line">/lib/x86_64-linux-gnu/libc.so.6<span class="o">(</span>+0x76d76<span class="o">)[</span>0x7fd77419fd76<span class="o">]</span>
</span><span class="line">/lib/x86_64-linux-gnu/libc.so.6<span class="o">(</span>cfree+0x6c<span class="o">)[</span>0x7fd7741a4aac<span class="o">]</span>
</span><span class="line">/usr/lib/x86_64-linux-gnu/libpcap.so.0.8<span class="o">(</span>+0x1b470<span class="o">)[</span>0x7fd774e2e470<span class="o">]</span>
</span><span class="line">/usr/lib/x86_64-linux-gnu/libpcap.so.0.8<span class="o">(</span>pcap_loop+0x2f<span class="o">)[</span>0x7fd774e1fecf<span class="o">]</span>
</span><span class="line">./main<span class="o">[</span>0x401869<span class="o">]</span>
</span><span class="line">/lib/x86_64-linux-gnu/libc.so.6<span class="o">(</span>__libc_start_main+0xfd<span class="o">)[</span>0x7fd774147ead<span class="o">]</span>
</span><span class="line">./main<span class="o">[</span>0x401001<span class="o">]</span>
</span><span class="line"><span class="o">=======</span> Memory map: <span class="o">========</span>
</span><span class="line">00400000-00402000 r-xp 00000000 08:08 1982169                            /home/kinglee/github/stuff/cplusplus/traffic_parser/main
</span><span class="line">00602000-00603000 rw-p 00002000 08:08 1982169                            /home/kinglee/github/stuff/cplusplus/traffic_parser/main
</span><span class="line">01dc8000-01de9000 rw-p 00000000 00:00 0                                  <span class="o">[</span>heap<span class="o">]</span>
</span><span class="line">7fd770000000-7fd770021000 rw-p 00000000 00:00 0
</span><span class="line">7fd770021000-7fd774000000 ---p 00000000 00:00 0
</span><span class="line">7fd774129000-7fd7742a9000 r-xp 00000000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so
</span><span class="line">7fd7742a9000-7fd7744a9000 ---p 00180000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so
</span><span class="line">7fd7744a9000-7fd7744ad000 r--p 00180000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so
</span><span class="line">7fd7744ad000-7fd7744ae000 rw-p 00184000 08:08 2097171                    /lib/x86_64-linux-gnu/libc-2.13.so
</span><span class="line">7fd7744ae000-7fd7744b3000 rw-p 00000000 00:00 0
</span><span class="line">7fd7744b3000-7fd7744c8000 r-xp 00000000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1
</span><span class="line">7fd7744c8000-7fd7746c8000 ---p 00015000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1
</span><span class="line">7fd7746c8000-7fd7746c9000 rw-p 00015000 08:08 2097156                    /lib/x86_64-linux-gnu/libgcc_s.so.1
</span><span class="line">7fd7746c9000-7fd77474a000 r-xp 00000000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so
</span><span class="line">7fd77474a000-7fd774949000 ---p 00081000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so
</span><span class="line">7fd774949000-7fd77494a000 r--p 00080000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so
</span><span class="line">7fd77494a000-7fd77494b000 rw-p 00081000 08:08 2097168                    /lib/x86_64-linux-gnu/libm-2.13.so
</span><span class="line">7fd77494b000-7fd774a33000 r-xp 00000000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17
</span><span class="line">7fd774a33000-7fd774c33000 ---p 000e8000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17
</span><span class="line">7fd774c33000-7fd774c3b000 r--p 000e8000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17
</span><span class="line">7fd774c3b000-7fd774c3d000 rw-p 000f0000 08:08 1314662                    /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.17
</span><span class="line">7fd774c3d000-7fd774c52000 rw-p 00000000 00:00 0
</span><span class="line">7fd774c52000-7fd774c72000 r-xp 00000000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so
</span><span class="line">7fd774e0e000-7fd774e13000 rw-p 00000000 00:00 0
</span><span class="line">7fd774e13000-7fd774e4b000 r-xp 00000000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0
</span><span class="line">7fd774e4b000-7fd774e4d000 r--p 00037000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0
</span><span class="line">7fd774e4d000-7fd774e4e000 rw-p 00039000 08:08 1331924                    /usr/lib/x86_64-linux-gnu/libpcap.so.1.3.0
</span><span class="line">7fd774e4e000-7fd774e4f000 rw-p 00000000 00:00 0
</span><span class="line">7fd774e6d000-7fd774e71000 rw-p 00000000 00:00 0
</span><span class="line">7fd774e71000-7fd774e72000 r--p 0001f000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so
</span><span class="line">7fd774e72000-7fd774e73000 rw-p 00020000 08:08 2097174                    /lib/x86_64-linux-gnu/ld-2.13.so
</span><span class="line">7fd774e73000-7fd774e74000 rw-p 00000000 00:00 0
</span><span class="line">7fff1591a000-7fff1593b000 rw-p 00000000 00:00 0                          <span class="o">[</span>stack<span class="o">]</span>
</span><span class="line">7fff159ff000-7fff15a00000 r-xp 00000000 00:00 0                          <span class="o">[</span>vdso<span class="o">]</span>
</span><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  <span class="o">[</span>vsyscall<span class="o">]</span>
</span><span class="line">已放弃
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于这个问题，当时表示怎么会出现内存错误？我指针根本没有指错啊！那块内存也没有回收阿！！原来的程序比较大，所以我就抽象写了个简单的，慢慢找。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="cp">#include &lt;string&gt;</span>
</span><span class="line"><span class="cp">#include &lt;iostream&gt;</span>
</span><span class="line"><span class="cp">#include &lt;algorithm&gt;</span>
</span><span class="line"><span class="cp">#include &lt;vector&gt;</span>
</span><span class="line">
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
</span><span class="line"><span class="k">typedef</span> <span class="k">class</span> <span class="nc">packet</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
</span><span class="line">    <span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="n">packet</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span> <span class="n">p</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">	<span class="c1">//注意这里，开始我写成了这样，一开始写顺了...</span>
</span><span class="line">	<span class="c1">//我本意是想申请一个长度为l的连续内存区域。</span>
</span><span class="line">	<span class="c1">//结果本意成为了申请了一个单位的内存，并给它赋值！！</span>
</span><span class="line">        <span class="n">data</span><span class="o">=</span><span class="k">new</span> <span class="kt">char</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
</span><span class="line">        <span class="c1">//应该写成这样</span>
</span><span class="line">        <span class="c1">//data=new char[l];</span>
</span><span class="line">        <span class="n">copy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">p</span><span class="o">+</span><span class="n">l</span><span class="p">,</span><span class="n">data</span><span class="p">);</span>
</span><span class="line">        <span class="n">len</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">packet</span><span class="p">(</span><span class="k">const</span> <span class="n">packet</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">len</span><span class="o">=</span><span class="n">p</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
</span><span class="line">        <span class="n">data</span><span class="o">=</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
</span><span class="line">        <span class="n">copy</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">data</span><span class="o">+</span><span class="n">len</span><span class="p">,</span><span class="n">data</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">packet</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">packet</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
</span><span class="line">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">];</span>
</span><span class="line">        <span class="n">copy</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">data</span><span class="o">+</span><span class="n">len</span><span class="p">,</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="o">~</span><span class="n">packet</span><span class="p">(){</span><span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;}</span>
</span><span class="line">    <span class="kt">char</span><span class="o">*</span> <span class="n">get_data</span><span class="p">(){</span><span class="k">return</span> <span class="n">data</span><span class="p">;}</span>
</span><span class="line">
</span><span class="line"><span class="p">}</span><span class="n">packet</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="n">vector</span><span class="o">&lt;</span><span class="n">packet</span><span class="o">&gt;</span> <span class="n">stream</span><span class="p">;</span>
</span><span class="line">    <span class="kt">char</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="s">&quot;hello world.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</span><span class="line">    <span class="n">packet</span> <span class="n">p</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
</span><span class="line">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">get_data</span><span class="p">(</span> <span class="p">)</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="n">stream</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class="line">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stream</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get_data</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span><span class="line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>编译运行就会出错。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="n">g</span><span class="o">++</span> <span class="n">test</span><span class="p">.</span><span class="n">cc</span> <span class="o">-</span><span class="n">o</span> <span class="n">main</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>所以，上述的语句是没有申请够足够的内存(只申请了一个，却按照那个长度来copy！！当然会出现数据覆盖的错误，这个属于语言错误)，所以会造成之后的内存覆盖，导致出错。有意思的是在windows平台上，我试过，是不会提示你出错的。
不过确实可以看到运行过程中不合理的地方。比如数据被覆盖了overlapping!（实验平台debian 7 ，g++ (Debian 4.7.2-5) 4.7.2
windows是win7 + mingw）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="c++"><span class="line"><span class="o">***</span> <span class="n">glibc</span> <span class="n">detected</span> <span class="o">***</span> <span class="p">.</span><span class="o">/</span><span class="nl">main:</span> <span class="kt">double</span> <span class="n">free</span> <span class="n">or</span> <span class="n">corruption</span> <span class="p">(</span><span class="n">fasttop</span><span class="p">)</span><span class="o">:</span> <span class="mh">0x0000000000e55010</span> <span class="o">***</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另外一点，在实际使用过程中，还是尽量不要混合使用malloc 和delete/delete[]</p>

<ul>
  <li>
    <p>使用malloc分配的内存尽量使用free释放掉</p>
  </li>
  <li>
    <p>使用new分配的内存，看情况，若是对象类型本身就是数组类型，使用delete[],否则使用delete释放掉内存</p>
  </li>
  <li>
    <p>使用new[]分配内存的，必须使用delete[] 来释放掉内存。否则只是释放掉了内存区域的第一个从而造成内存泄漏。</p>
  </li>
</ul>

<blockquote>
  <blockquote>
    <p>参考</p>
  </blockquote>
</blockquote>

<ul>
  <li>
    <p><a href="http://stackoverflow.com/questions/18389313/glibc-detected-main-free-invalid-next-size-fast">’** glibc detected *** ./main: free(): invalid next size (fast):’</a></p>
  </li>
  <li>
    <p><a href="http://www.cplusplus.com/reference/cstring/memcpy/?kw=memcpy">‘好好使用memcpy’</a></p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解TCP中的序列号和确认号]]></title>
    <link href="http://aluenkinglee.com/blog/2014/02/26/li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/"/>
    <updated>2014-02-26T22:34:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/02/26/li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao</id>
    <content type="html"><![CDATA[<p>之所以写这么一篇文章是因为被wireshark的序列号搞晕了，我不知道你们是否这样，当你读这篇article时，肯定你已经熟悉了TCP那个三次握手，
或者是SYN,SYN|ACK,ACK. 而我要做的也就是这个，提取一个流的前N个packets，针对目前的需求，只需要在传输层截取UDP和TCP的前多少个流即可。
所以我得分析网络层的这些协议底层到底是怎么回事，在结合libpcap完成流的提取任务。</p>

<p>相对来说TCP还是个复杂的协议，而且值得清楚的认识以下。那么结合wireshark和代码来认识下TCP里面的东西。</p>

<!--more-->

<p><a href="https://github.com/aluenkinglee/stuff/blob/master/cplusplus/traffic_parser/b.pcap?raw=true" title="pcap文件">这里</a>是个已经准备好的pcap文件，本文结合这个文件对此进行描述。</p>

<p>这个文件分析的是微信在单一环境中的网络行为，所以比较简单。打开这个文件，找到开始的几个右键单击选择<code>Follow TCP Stream</code>，或者在filter那里输入<code>tcp.stream eq 1</code>可以看到这里。</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp1.png?raw=true" alt="Follow TCP Stream" title="Follow TCP Stream" /></p>

<h4 id="section">三次握手</h4>

<p>TCP利用了8个标志位，在头部位置，以此来控制链接的状态，对我们最有用的就是SYN，ACK，FIN了。</p>

<ul>
  <li>SYN - (Synchronize) Initiates a connection</li>
  <li>FIN - (Final) Cleanly terminates a connection</li>
  <li>ACK - Acknowledges received data</li>
</ul>

<p>下面将会看到，一个packet包含了多个flag set。</p>

<h6 id="flagssyn10">对于这个流的第一个，注意Flags里面出了SYN位是1之外，其它都是0。</h6>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp2.png?raw=true" alt="第一次握手" title="第一次握手" /></p>

<h6 id="synack">接下来在看第二个，注意它有两个标志位被设置为1，分别是SYN和ACK。</h6>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp3.png?raw=true" alt="第二次握手" title="第二次握手" /></p>

<h6 id="packetack">对于第三个packet，就只有ACK设置了。</h6>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp4.png?raw=true" alt="第三次握手" title="第三次握手" /></p>

<p>这就是最初的TCP三次握手。</p>

<h4 id="seqack">序列号和应答号（SEQ和ACK）</h4>

<p>假设客户端为A，服务器为B，双方都为护着一个32bit的序列号，用来追踪传输了多少数据。。这个号包括了之前所传输的负载的
大小，由另一端的应答号来应答“你传的数据我都收到了。。”</p>

<p>当一个机器开始初始TCP序列号时，它是随机的！！不然会出现序列号攻击。。（我忘记了，在用那个wireshark后成功被它的相对序列号迷惑了==）,是一个0～ $2^{32}-1$的数。相对序列号是给人看的，所以像wireshark之辈使用它是为了人们方便阅读理解的。
（选择不启用相对序列号：选择<code>Edit &gt; Preferences... </code>不启用那个<code>Relative sequence numbers and window scaling </code>就可以了）</p>

<p>接下来让我们结合下图来看这个流的行为。在<code>Statistics &gt; Flow Graph...</code>选择<code>TCP flow</code>。</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-02-26-li-jie-tcpzhong-de-xu-lie-hao-he-que-ren-hao/tcp5.png?raw=true" alt="流图" title="流图" /></p>

<p>这张图很容易理解就不说了。使用这张流图可以很方便的帮助我们理解他们是怎么工作的。</p>

<h6 id="packet-1">packet #1</h6>

<p>A向B发了一个请求，我们可以在frame的tcp中分析出来，SYN=1而ACK=0，这意味这是一个流的起始包。这里使用的是相对序列号，所以为0.</p>

<h6 id="packet-2">packet #2</h6>

<p>B收到了响应，恩，因为这是会话的开始，所以B这边也生成了一个随机的序列号，只不过在这里也显示为0了。SYN置为1。另外ACK也置为1，表明收到了A的响应。
(注意！虽然A没有发送任何负载payload，B仍然把ACK置为1，是因为收到的SYN或者FIN触发了这个增1行为。这儿不会涉及到任何负载长度的计算，因为带有这样信号的包不会携带负载的。)</p>

<h6 id="packet-3">packet #3</h6>

<p>和#2一样，A回应了B的响应（SEQ=0，ACK=1）所以ACK为1.自己的SEQ因为收到的包中有SYN所以变为1。此时，双方的SEQ都是1，这种现象在所有TCP开始建立连接时候都是一样的。</p>

<h6 id="packet-4">packet #4</h6>

<p>A这个包此时带有负载，这里的SEQ是1，因为上个包（#3）没有传输任何数据，ACK也是1，因为A没有传输任何数据。注意！packet的长度是341，但是我们计算的是传输层的数据长度–负载的长度，所以是ACK — LEN = LEN（#4）-LEN（#3） = 341 - 66 = 275。</p>

<h6 id="packet-5">packet #5</h6>

<p>这个包是B（#5）对A（#4）发送数据的响应，此时B的ACK加上负载的长度是275变为276，表示我B收到了你A传输的数据payload（#4）. B此时的SEQ仍为1.</p>

<h6 id="packet-6">packet #6</h6>

<p>这个包是B对A放送的HTTP响应，因为之前它（B）所有的包都没有负载，所以SEQ仍然为1，而ACK还是276.负载长度为627.</p>

<h6 id="packet-7">packet #7</h6>

<p>好吧，这个例子有点特殊，到这里为止B的数据就发送完了。。。所以FIN置为1，表明你（A）要得我（B）都给完了，没我的事儿了，SEQ加上我发送的数据长度为628，你那边确认之后应该和我一样才对。ACK还是之前你给我发送的那些数据，还是这些276.</p>

<h6 id="packet-8">packet #8</h6>

<p>A:收到了所有的数据，我先确认给你我数据我收到了，ACK加上627变为628。我之前发送的数据截止到目前是276，没错，我们对上了。</p>

<h6 id="packet-9">packet #9</h6>

<p>A:既然我都要到了，那么我们就分手吧~~ 同意，FIN置为1，因为从B收到了带有FIN的报文（#7），所以ACK+1，变为629。因为上个数据包#8 没有发送任何数据，所以这里的SEQ不变,</p>

<h6 id="packet-10">packet #10</h6>

<p>因为#9带有FIN，所以SEQ自增1.ACK不变。</p>

<p>关于代码，请看下篇。</p>

<h2 id="section-1">参考</h2>

<ol>
  <li>
    <p><a href="http://stackoverflow.com/questions/2672734/tcp-sequence-number-question">TCP sequence number question</a></p>
  </li>
  <li>
    <p><a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</a></p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++的hashtable那些事]]></title>
    <link href="http://aluenkinglee.com/blog/2014/02/24/c-plus-plus-de-hashtablena-xie-shi/"/>
    <updated>2014-02-24T05:29:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/02/24/c-plus-plus-de-hashtablena-xie-shi</id>
    <content type="html"><![CDATA[<p>对于想知道hashtable原理的的人来说，多少对基本的数据结构和算法都有些了解，所以不再细说。</p>

<p>平常我们所说的一些容器来说，比如vector，list，stack之类，他们中的元素都是可以排序的，可以归为序列式容器，基于连续内存的vector可以实现随机存储，但是搜索的复杂度是O（n），list也是如此。
在关联式容器中，每个数据有一个键值和一个实值。元素插入到关联式容器中，容器内部结构根据其键值依据某个特定的规则将这个元素放置于适当的位置，从而实现插入和搜索是对数平均时间（基于红黑树），甚至是尽可能的是常数级别（就是这里说的散列表），其效率依赖于数据的特性和规则的设计。关联式的容器没有所谓的头尾，不会有begin(),end(),push_back()等这样的行为。</p>

<p>数组是个很好的内建数据结构，你甚至可以把数组看成一个最简单的hash表，index是种键值，而内容则是value。是不是很好，常数级寻址。但是也有问题，通常我们面对的键值不仅仅是简单的无符号的整数之流，还有很多的string啊，复杂的类对象啊，而这些问题就是hash函数所要处理的问题。hash函数把这个对象映射到[0-表的长度-1]之间。但是，不能够保证每个元素的键值与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。 总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。首先，为什么会出现冲突？基于这种想法设计出来的结构无疑是一种空间换时间的典范，尽管现在硬件越来越牛逼，但并不意味着可以随便挥霍，矛盾就出现在空间的数据往往小于我们要处理的数据规模，所以我们不可能设计出一种一一对应的函数来。而解决冲突就是hash第二个要解决的问题。</p>

<p>对于冲突的解决，往往有线性探测和二测探测以及开链法（类似list），前两种往往在数据规模小的情况下，即空间浪费的时候效率较高，这也意味着空间利用率不是很理想，而开链法，器负载系数大于1，就是索引的数组被极大利用了。
<!--more--></p>

<p>所以在hashtable中，把一个元素（对象）插入到其中，分为以下的过程：</p>

<p>1.得到元素的键值Key。</p>

<p>2.调用处理该键型KeyType的hash函数(有时候需要用户自己编写)得到hash值（即下标）。</p>

<p>3.把该元素存放到对应该下标的桶内。</p>

<p>查找，取值的过程:</p>

<p>1.得到元素的键值Key。</p>

<p>2.调用处理该键型KeyType的hash函数得到hash值（即下标）。</p>

<p>3.比较桶的内部元素是否与key相等（编写equal_to函数，基本类型意外用户根据需求编写），若都不相等，则没有找到。</p>

<p>4.取出相等的记录的value。</p>

<p>综上所述，实现一个hashtable必须注意hash函数 和 比较函数的接口提供。</p>

<h5 id="hashtable">hashtable迭代器的设计</h5>

<p>首先明确我们的需求，定位有hash函数搞定，而找到该桶之后，只是需要顺着桶往下找就够了，所以迭代器是个前向迭代器，对应的接口有实值，键值，hash仿函数，提取仿函数，等于仿函数，还有空间配置器等。其他编写仿照一般的迭代器设计即可。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
</span><span class="line">         <span class="k">class</span> <span class="nc">HashFcn</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ExtractKey</span><span class="p">,</span>
</span><span class="line">         <span class="k">class</span> <span class="nc">EqualKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">struct</span> <span class="n">__hashtable_iterator</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">hashtable</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">HashFcn</span><span class="p">,</span> <span class="n">ExtractKey</span><span class="p">,</span> <span class="n">EqualKey</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span> <span class="n">HashTable</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">__hashtable_iterator</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span>
</span><span class="line">            <span class="n">HashFcn</span><span class="p">,</span> <span class="n">ExtractKey</span><span class="p">,</span>
</span><span class="line">            <span class="n">EqualKey</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span>
</span><span class="line">            <span class="n">iterator</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">__hashtable_iterator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span>
</span><span class="line">            <span class="n">HashFcn</span><span class="p">,</span> <span class="n">ExtractKey</span><span class="p">,</span>
</span><span class="line">            <span class="n">EqualKey</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span>
</span><span class="line">            <span class="n">const_iterator</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">typedef</span> <span class="n">__hashtable_nodes</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//因为是前向移动，没有后退操作--</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">forward_iterator_tag</span>    <span class="n">iterator_categor</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">Value</span>                   <span class="n">value_type</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">ptrdiff_t</span>               <span class="n">difference_type</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">size_t</span>                  <span class="n">size_type</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">Value</span><span class="o">*</span>                  <span class="n">pointer</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">Value</span><span class="o">&amp;</span>                  <span class="n">reference</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="n">node</span><span class="o">*</span> <span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="n">HashTable</span><span class="o">*</span> <span class="n">ht</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//constructor</span>
</span><span class="line">    <span class="n">__hashtable_iterator</span><span class="p">(</span><span class="n">node</span><span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">HashTable</span><span class="o">*</span> <span class="n">tab</span><span class="p">)</span> <span class="o">:</span> <span class="n">cur</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">ht</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span> <span class="p">{}</span>
</span><span class="line">    <span class="n">__hashtable_iterator</span><span class="p">()</span> <span class="p">{}</span>
</span><span class="line">
</span><span class="line">    <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span>  <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">pointer</span>   <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">operator</span><span class="o">*</span><span class="p">());</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
</span><span class="line">    <span class="n">iterator</span>  <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span><span class="line">    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">cur</span> <span class="o">==</span> <span class="n">it</span><span class="p">.</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">cur</span> <span class="o">!=</span> <span class="n">it</span><span class="p">.</span><span class="n">cur</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>详情请看<a href="https://github.com/aluenkinglee/stuff/blob/master/cplusplus/stl/hashtable#L127" title="__hashtable_iterator">__hashtable_iterator</a></p>

<h5 id="hashtable-1">hashtable的数据结构</h5>

<p>由于采用开链的冲突解决方法，由此看来只需要一个vector代替桶，链表来装载桶内的元素即可。</p>

<p>需要注意的是hash函数，提取函数，等于函数的成员。另外需要buckets，还有元素数目的成员，有了这些基本就够了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
<span class="line-number">81</span>
<span class="line-number">82</span>
<span class="line-number">83</span>
<span class="line-number">84</span>
<span class="line-number">85</span>
<span class="line-number">86</span>
<span class="line-number">87</span>
<span class="line-number">88</span>
<span class="line-number">89</span>
<span class="line-number">90</span>
<span class="line-number">91</span>
<span class="line-number">92</span>
<span class="line-number">93</span>
<span class="line-number">94</span>
<span class="line-number">95</span>
<span class="line-number">96</span>
<span class="line-number">97</span>
<span class="line-number">98</span>
<span class="line-number">99</span>
<span class="line-number">100</span>
<span class="line-number">101</span>
<span class="line-number">102</span>
<span class="line-number">103</span>
<span class="line-number">104</span>
<span class="line-number">105</span>
<span class="line-number">106</span>
<span class="line-number">107</span>
<span class="line-number">108</span>
<span class="line-number">109</span>
<span class="line-number">110</span>
<span class="line-number">111</span>
<span class="line-number">112</span>
<span class="line-number">113</span>
<span class="line-number">114</span>
<span class="line-number">115</span>
<span class="line-number">116</span>
<span class="line-number">117</span>
<span class="line-number">118</span>
<span class="line-number">119</span>
<span class="line-number">120</span>
<span class="line-number">121</span>
<span class="line-number">122</span>
<span class="line-number">123</span>
<span class="line-number">124</span>
<span class="line-number">125</span>
<span class="line-number">126</span>
<span class="line-number">127</span>
<span class="line-number">128</span>
<span class="line-number">129</span>
<span class="line-number">130</span>
<span class="line-number">131</span>
<span class="line-number">132</span>
<span class="line-number">133</span>
<span class="line-number">134</span>
<span class="line-number">135</span>
<span class="line-number">136</span>
<span class="line-number">137</span>
<span class="line-number">138</span>
<span class="line-number">139</span>
<span class="line-number">140</span>
<span class="line-number">141</span>
<span class="line-number">142</span>
<span class="line-number">143</span>
<span class="line-number">144</span>
<span class="line-number">145</span>
<span class="line-number">146</span>
<span class="line-number">147</span>
<span class="line-number">148</span>
<span class="line-number">149</span>
<span class="line-number">150</span>
<span class="line-number">151</span>
<span class="line-number">152</span>
<span class="line-number">153</span>
<span class="line-number">154</span>
<span class="line-number">155</span>
<span class="line-number">156</span>
<span class="line-number">157</span>
<span class="line-number">158</span>
<span class="line-number">159</span>
<span class="line-number">160</span>
<span class="line-number">161</span>
<span class="line-number">162</span>
<span class="line-number">163</span>
<span class="line-number">164</span>
<span class="line-number">165</span>
<span class="line-number">166</span>
<span class="line-number">167</span>
<span class="line-number">168</span>
<span class="line-number">169</span>
<span class="line-number">170</span>
<span class="line-number">171</span>
<span class="line-number">172</span>
<span class="line-number">173</span>
<span class="line-number">174</span>
<span class="line-number">175</span>
<span class="line-number">176</span>
<span class="line-number">177</span>
<span class="line-number">178</span>
<span class="line-number">179</span>
<span class="line-number">180</span>
<span class="line-number">181</span>
<span class="line-number">182</span>
<span class="line-number">183</span>
<span class="line-number">184</span>
<span class="line-number">185</span>
<span class="line-number">186</span>
<span class="line-number">187</span>
<span class="line-number">188</span>
<span class="line-number">189</span>
<span class="line-number">190</span>
<span class="line-number">191</span>
<span class="line-number">192</span>
<span class="line-number">193</span>
<span class="line-number">194</span>
<span class="line-number">195</span>
<span class="line-number">196</span>
<span class="line-number">197</span>
<span class="line-number">198</span>
<span class="line-number">199</span>
<span class="line-number">200</span>
<span class="line-number">201</span>
<span class="line-number">202</span>
<span class="line-number">203</span>
<span class="line-number">204</span>
<span class="line-number">205</span>
<span class="line-number">206</span>
<span class="line-number">207</span>
<span class="line-number">208</span>
<span class="line-number">209</span>
<span class="line-number">210</span>
<span class="line-number">211</span>
<span class="line-number">212</span>
<span class="line-number">213</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="c1">//hashtable的数据结构</span>
</span><span class="line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Key</span><span class="p">,</span>
</span><span class="line">         <span class="k">class</span> <span class="nc">HashFcn</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ExtractKey</span><span class="p">,</span>
</span><span class="line">         <span class="k">class</span> <span class="nc">EqualKey</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Alloc</span><span class="o">&gt;</span>
</span><span class="line"><span class="k">class</span> <span class="nc">hashtable</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">Value</span> <span class="n">value_type</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">value_type</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="k">const</span> <span class="n">pointer</span> <span class="n">const_pointer</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">reference</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="k">const</span> <span class="n">reference</span> <span class="n">const_reference</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">Key</span> <span class="n">key_type</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">HashFcn</span> <span class="n">hasher</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">EqualKey</span> <span class="n">key_equal</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">size_t</span> <span class="n">size_type</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">__hashtable_iterator</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">HashFcn</span><span class="p">,</span> <span class="n">ExtractKey</span><span class="p">,</span> <span class="n">EqualKey</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">__hashtable_iterator</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">HashFcn</span><span class="p">,</span> <span class="n">ExtractKey</span><span class="p">,</span> <span class="n">EqualKey</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">const_iterator</span><span class="p">;</span>
</span><span class="line"><span class="c1">//constructor</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="n">hashtable</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
</span><span class="line">              <span class="k">const</span> <span class="n">HashFcn</span> <span class="o">&amp;</span><span class="n">hf</span><span class="p">,</span>
</span><span class="line">              <span class="k">const</span> <span class="n">EqualKey</span> <span class="o">&amp;</span><span class="n">eql</span><span class="p">,</span>
</span><span class="line">              <span class="k">const</span> <span class="n">ExtractKey</span> <span class="o">&amp;</span><span class="n">ext</span><span class="p">)</span>
</span><span class="line">        <span class="o">:</span><span class="n">hash</span><span class="p">(</span><span class="n">hf</span><span class="p">),</span><span class="n">equals</span><span class="p">(</span><span class="n">eql</span><span class="p">),</span><span class="n">get_key</span><span class="p">(</span><span class="n">ext</span><span class="p">),</span><span class="n">num_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">initialize_buckets</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">hashtable</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span>
</span><span class="line">              <span class="k">const</span> <span class="n">HashFcn</span> <span class="o">&amp;</span><span class="n">hf</span><span class="p">,</span>
</span><span class="line">              <span class="k">const</span> <span class="n">EqualKey</span> <span class="o">&amp;</span><span class="n">eql</span><span class="p">)</span>
</span><span class="line">        <span class="o">:</span><span class="n">hash</span><span class="p">(</span><span class="n">hf</span><span class="p">),</span><span class="n">equals</span><span class="p">(</span><span class="n">eql</span><span class="p">),</span><span class="n">get_key</span><span class="p">(</span><span class="n">ExtractKey</span><span class="p">()),</span><span class="n">num_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">initialize_buckets</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="n">hashtable</span><span class="p">(</span><span class="k">const</span> <span class="n">hashtable</span> <span class="o">&amp;</span><span class="n">ht</span><span class="p">)</span>
</span><span class="line">        <span class="o">:</span><span class="n">hash</span><span class="p">(</span><span class="n">ht</span><span class="p">.</span><span class="n">hash</span><span class="p">),</span><span class="n">equals</span><span class="p">(</span><span class="n">ht</span><span class="p">.</span><span class="n">equals</span><span class="p">),</span><span class="n">get_key</span><span class="p">(</span><span class="n">ht</span><span class="p">.</span><span class="n">get_key</span><span class="p">),</span><span class="n">num_elements</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">copy_from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="o">~</span><span class="n">hashtable</span><span class="p">()</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">clear</span><span class="p">();</span>
</span><span class="line">    <span class="p">};</span>
</span><span class="line">
</span><span class="line">    <span class="n">hashtable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">hashtable</span> <span class="o">&amp;</span><span class="n">ht</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span> <span class="o">!=</span> <span class="k">this</span><span class="p">)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">clear</span><span class="p">();</span>
</span><span class="line">            <span class="n">hash</span> <span class="o">=</span> <span class="n">ht</span><span class="p">.</span><span class="n">hash</span><span class="p">;</span>
</span><span class="line">            <span class="n">equals</span> <span class="o">=</span> <span class="n">ht</span><span class="p">.</span><span class="n">equals</span><span class="p">;</span>
</span><span class="line">            <span class="n">get_key</span> <span class="o">=</span> <span class="n">ht</span><span class="p">.</span><span class="n">get_key</span><span class="p">;</span>
</span><span class="line">            <span class="n">copy_from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ht</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="n">hasher</span> <span class="n">hash</span><span class="p">;</span>
</span><span class="line">    <span class="n">key_equal</span> <span class="n">equals</span><span class="p">;</span>
</span><span class="line">    <span class="n">ExtractKey</span> <span class="n">get_key</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="k">typedef</span> <span class="n">__hashtable_nodes</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">;</span>
</span><span class="line">    <span class="k">typedef</span> <span class="n">simple_alloc</span><span class="o">&lt;</span><span class="n">node</span><span class="p">,</span> <span class="n">Alloc</span><span class="o">&gt;</span> <span class="n">node_allocator</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//std::vector&lt;node*, Alloc&gt; buckets;</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">buckets</span><span class="p">;</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">num_elements</span><span class="p">;</span>
</span><span class="line"><span class="k">public</span><span class="o">:</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">node</span><span class="o">*&gt;</span> <span class="n">getBuckets</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">buckets</span><span class="p">;}</span>
</span><span class="line">    <span class="c1">//返回bucket vector大小</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">bucket_count</span><span class="p">()</span> <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">buckets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//返回bucket vector可能的最大值</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">max_bucket_count</span><span class="p">()</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">__stl_prime_list</span><span class="p">[</span><span class="n">__stl_num_primes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//返回元素个数</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">size</span><span class="p">()</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">num_elements</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//找到起始节点</span>
</span><span class="line">    <span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">size_type</span> <span class="n">bucketIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">        <span class="n">node</span><span class="o">*</span> <span class="n">first</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">bucketIndex</span><span class="p">];</span>
</span><span class="line">                <span class="o">!</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">bucketIndex</span> <span class="o">&lt;</span> <span class="n">buckets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class="line">                <span class="n">first</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">bucketIndex</span><span class="p">])</span> <span class="p">{}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//插入元素，不允许重复</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_unique</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">resize</span><span class="p">(</span><span class="n">num_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">insert_unique_noresize</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//插入元素，允许重复</span>
</span><span class="line">    <span class="n">iterator</span> <span class="n">insert_equal</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">resize</span><span class="p">(</span><span class="n">num_elements</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">insert_equal_noresize</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//查找某一键值的节点</span>
</span><span class="line">    <span class="n">iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">size_type</span> <span class="n">bucketIndex</span> <span class="o">=</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span><span class="line">        <span class="n">node</span><span class="o">*</span> <span class="n">first</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span> <span class="n">first</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">bucketIndex</span><span class="p">];</span>
</span><span class="line">                <span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">equals</span><span class="p">(</span><span class="n">get_key</span><span class="p">(</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">),</span> <span class="n">key</span><span class="p">);</span>
</span><span class="line">                <span class="n">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//判断某一值出现的次数</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">const</span> <span class="n">size_type</span> <span class="n">bucketIndex</span> <span class="o">=</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span><span class="line">        <span class="n">size_type</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">node</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">bucketIndex</span><span class="p">];</span>
</span><span class="line">                <span class="n">cur</span><span class="p">;</span>
</span><span class="line">                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
</span><span class="line">            <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">get_key</span><span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">),</span> <span class="n">key</span><span class="p">))</span>
</span><span class="line">                <span class="o">++</span><span class="n">result</span><span class="p">;</span>
</span><span class="line">        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//判断元素落在哪个bucket</span>
</span><span class="line">    <span class="c1">//提供两个版本</span>
</span><span class="line">    <span class="c1">//版本一：只接受实值</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">bkt_num</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="n">get_key</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//版本二：接受实值和buckets个数</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">bkt_num</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="n">get_key</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span><span class="n">n</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//返回在index处的节点个数</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">elems_in_bucket</span><span class="p">(</span><span class="n">size_type</span> <span class="n">bucketIndex</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">size_type</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">        <span class="n">node</span><span class="o">*</span> <span class="n">tempNode</span> <span class="o">=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">bucketIndex</span><span class="p">];</span>
</span><span class="line">        <span class="k">while</span><span class="p">(</span><span class="n">tempNode</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="n">tempNode</span> <span class="o">=</span> <span class="n">tempNode</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class="line">        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//整体删除</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">clear</span><span class="p">();</span>
</span><span class="line">    <span class="c1">//复制hash表</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">copy_from</span><span class="p">(</span><span class="k">const</span> <span class="n">hashtable</span><span class="o">&amp;</span> <span class="n">ht</span><span class="p">);</span>
</span><span class="line"><span class="k">private</span><span class="o">:</span>
</span><span class="line">    <span class="c1">//初始化buckets vector</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">initialize_buckets</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">const</span> <span class="n">size_type</span> <span class="n">n_buckets</span> <span class="o">=</span> <span class="n">next_size</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class="line">        <span class="n">buckets</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n_buckets</span><span class="p">);</span>
</span><span class="line">        <span class="n">buckets</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">buckets</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">n_buckets</span><span class="p">,</span> <span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">);</span>
</span><span class="line">        <span class="n">num_elements</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//节点配置和释放函数</span>
</span><span class="line">    <span class="n">node</span><span class="o">*</span> <span class="n">new_node</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="c1">//node *tempNode = node_allocator::allocate();</span>
</span><span class="line">        <span class="n">node</span><span class="o">*</span> <span class="n">tempNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="p">;</span>
</span><span class="line">        <span class="n">tempNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="k">try</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="n">construct</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tempNode</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">catch</span> <span class="p">(...)</span>
</span><span class="line">        <span class="p">{</span>
</span><span class="line">            <span class="c1">//node_allocator::deallocate(tempNode);</span>
</span><span class="line">            <span class="k">delete</span> <span class="n">tempNode</span><span class="p">;</span>
</span><span class="line">            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">tempNode</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="kt">void</span> <span class="n">delete_node</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">n</span><span class="p">)</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="n">destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
</span><span class="line">        <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//返回最接近n并大于等于n的质数</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">next_size</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span><span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">__get_next_prime</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//版本一：只接受键值</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">buckets</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="c1">//版本二：接受键值和buckets个数</span>
</span><span class="line">    <span class="n">size_type</span> <span class="n">bkt_num_key</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span><span class="n">size_type</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span>
</span><span class="line">    <span class="p">{</span>
</span><span class="line">        <span class="k">return</span> <span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">
</span><span class="line">    <span class="c1">//判断是否需要扩充buckets vector，如有需要则进行扩充</span>
</span><span class="line">    <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="n">size_type</span> <span class="n">num_elements_hint</span><span class="p">);</span>
</span><span class="line">    <span class="c1">//在不需要重新分配bucket vector的情况下插入元素，元素不允许重复</span>
</span><span class="line">    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert_unique_noresize</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">);</span>
</span><span class="line">    <span class="c1">//在不需要重新分配bucket vector的情况下插入元素，元素不允许重复</span>
</span><span class="line">    <span class="n">iterator</span> <span class="n">insert_equal_noresize</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">);</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>至于更多的请看代码（由于是简易实现的，配置器那块并没有使用stl的配置器，简单写了下）<a href="https://github.com/aluenkinglee/stuff/blob/master/cplusplus/stl/hashtable#L127" title="hashtable">hashtable</a></p>

<p>基于hashtable可以实现hash_set,hash_map,hash_multiset,hash_multimap,是这些容器的底层实现，而map,set,multiset,multimap则是基于rb-tree实现的，这是区别之一。</p>

<p>另外使用基于hashtable的时候需要提供hash仿函数，提取仿函数，等于仿函数这些参数。而基于rb-tree实现的需要比较函数即可。</p>

<p>平常时间根据查找速度, 数据量, 内存使用三个因素权衡，是否适合使用hashtable。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Machine Learning :linear regression]]></title>
    <link href="http://aluenkinglee.com/blog/2014/01/05/machine-learning-linear-regression/"/>
    <updated>2014-01-05T12:00:00+08:00</updated>
    <id>http://aluenkinglee.com/blog/2014/01/05/machine-learning-linear-regression</id>
    <content type="html"><![CDATA[<p>机器学习中，总体来说是分为两类问题：</p>

<p>1.有监督的学习方法
2.无监督的学习方法</p>

<p>其他是这两者的综合，比如说半监督学习方法，强化学习（这个还未接触过）。</p>

<p>本文呢，先从有监督的学习方法开始讲起，主要是记载学习过程中个人认为最重要的地方。</p>

<p>对于监督学习中的两类问题，或者说三类吧，分别是：回归问题，分类问题和标注问题（tagging）。后面这个很有意思，不过在这里现说一下回归和分类的区别，假如我们要
做一个连续变量的预测，比如说房价的预测，或者明日气温的预测，都是属于回归问题；而对于离散变量的预测，比如判断一个病人是否得了癌症，良性还是恶心，则是一个明显的分
类问题。</p>

<p>接下来的文章，大概是对Andrew Ng视频的一个简单的总结，会结合变成实例（octave和C++）来插叙。
<!--more--></p>

<h3 id="section">线性回归</h3>

<p>好吧，先从一个简单的例子讲起，假设我们要为一个房子售价做个数学模型，价格和什么有关系？当然因素很多，比如房间的大小，离商业区的距离，嗯，房子几坪，奥，看起来不是
个简单事儿～，那好吧，遵循我们先从最简单做起的原则，现假设相同尺寸的房子价格和城市人口多少有关系，其他的先抛到一边去，我喜欢做甩手掌柜==
，你看这很合理！北京上海的房子价格能和三四线城市的比么=。=</p>

<p>那么好，我们会看到下面这个图！图先不上！！！假设你装了octave，并执行ex1的话就会看到它的！！</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-01-05-machine-learning-linear-regression/linear_regression_f1.png?raw=true" alt="价格-人口关系图" title="价格-人口关系图" /></p>

<p>在那之前，先让我们约定几个问题，恩恩：</p>

<h5 id="section-1">注释</h5>
<ul>
  <li>$m$ ：是训练实例的个数</li>
  <li>$x$ ：是输入的特征向量,很有可能是这样子：$x=(x_1,…,x_k)$</li>
  <li>$y$ ：是输出结果</li>
  <li>$(x,y)$ ：是一个训练实例</li>
  <li>$(x^{(i)},y^{(i)})$ ：表示第i个训练样例</li>
</ul>

<p>好了，让我们接着开始吧。那我们应该如何表示我们的假设（hypothesis）呢？既然只有一个变量，这样表示好了：</p>

<script type="math/tex; mode=display">
h_\theta(x) = \theta_0 + \theta_1x_1 ， \Theta={ (\theta_0,\theta_1) }
</script>

<p>那应该如何选择参数$\theta$呢？机器学习不就是干这活的么=。=</p>

<p>直观的感受就是：“嘿，干嘛不用LMS最小二乘法？无脑流，简单又实惠！统计课上的入门案例。。”就他了。。。</p>

<p>所以，总结如下：</p>

<p>假设：</p>

<script type="math/tex; mode=display">
h_\theta(x) = \theta_0 x_0 + \theta_1 x_1 ， 
\Theta = \left( \begin{array}{c}
        \theta_0 \\
        \theta_1
        \end{array} \right), 
x = (x_0,x_1),
x_0 \equiv 1 \\
h_\theta(x) = x \cdot \Theta
</script>

<p>费用函数：</p>

<script type="math/tex; mode=display">
J{(\Theta)}=\frac{1}{2m} \sum\limits_{i=1}^m \left(h_\theta(x^{(i)})-y^{(i)}
\right)^2 
</script>

<p>目标：</p>

<script type="math/tex; mode=display">
\min\limits_{\Theta} J{(\Theta)}
</script>

<p>回想下我们学过的数学知识吧，给定一个函数，求函数的最值，导数？梯度？那一套东西想起来了吧，OK。那好办了。要是还不是很清楚，那看一下<a href="http://zh
.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6">梯度</a>以及<a href="http://zh.wikipedia.org/wiki/%
E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95">梯度下降法</a>在此就不罗嗦了。Andrew
Ng在视频中讲的很形象，只要我们沿着山最陡的方向向下走，就会有可能找到最小值，翻译成数学语言就是沿着梯度相反的方向$- \nabla F(x)$,
就可以下降最快。（我们不是要找最小值么，当然是水往低处流！所以就是负值了）</p>

<h4 id="section-2">梯度下降法</h4>

<p>选定了回归模型，那就要确定参数$\Theta$了，$\Theta$只有在$J{(\Theta)}
$最小的情况下才能确定，所以问题归结为了求极小值的问题，梯度下降法是个不错的选择。当然，它会遇到找到的值只是个局部最小值。</p>

<p>这是示意图：</p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-01-05-machine-learning-linear-regression/linear_regression_f4.png?raw=true" alt="最小值" /></p>

<p><img src="https://github.com/aluenkinglee/aluenkinglee.github.io/blob/source/source/images/2014-01-05-machine-learning-linear-regression/linear_regression_f5.png?raw=true" alt="局部极小值" /></p>

<p>流程如下：</p>

<ol>
  <li>对$\Theta$赋予初始值，可随机，可为零向量。</li>
  <li>同步改变$\Theta$值，使得$J{(\Theta)}$沿着梯度下降的方向走，直到学习曲线平滑，也就是收敛。</li>
</ol>

<p>用公式来描述就是,对于$j=1$和$j=0$，同时重复以下操作，直到$J{(\Theta)}$收敛。</p>

<script type="math/tex; mode=display">
\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j}
J{(\theta_0,\theta_1) } \\
\theta_j := \theta_j - \alpha \frac{1}{m} \sum\limits_{i=1}^m 
\left(h_\theta(x^{(i)})-y^{(i)}
\right) \cdot x_j^{(i)}
</script>

<p>这是octave实现，向量形式,代码<a href="https://github.com/aluenkinglee/mlclass/blob/master/
mlclass-ex1/gradientDescent.m">详见</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
</pre></td><td class="code"><pre><code class="octave"><span class="line"><span class="k">function</span><span class="w"> </span>[theta, J_history] <span class="p">=</span><span class="w"> </span><span class="nf">gradientDescent</span><span class="p">(</span>X, y, theta, alpha, num_iters<span class="p">)</span><span class="w"></span>
</span><span class="line"><span class="c">%GRADIENTDESCENT Performs gradient descent to learn theta</span>
</span><span class="line"><span class="c">%   theta = GRADIENTDESENT(X, y, theta, alpha, num_iters) updates theta by </span>
</span><span class="line"><span class="c">%   taking num_iters gradient steps with learning rate alpha</span>
</span><span class="line">
</span><span class="line"><span class="c">% Initialize some useful values</span>
</span><span class="line"><span class="n">m</span> <span class="p">=</span> <span class="nb">length</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c">% number of training examples</span>
</span><span class="line"><span class="n">J_history</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">num_iters</span><span class="p">,</span> 1<span class="p">);</span>
</span><span class="line"><span class="k">for</span> <span class="n">iter</span> <span class="p">=</span> 1<span class="p">:</span><span class="n">num_iters</span>
</span><span class="line">    <span class="c">%theta1 = theta(1) - alpha * X(:,1)&#39; *(X * theta - y) / m;</span>
</span><span class="line">    <span class="c">%theta2 = theta(2) - alpha * X(:,2)&#39; *(X * theta - y) / m;</span>
</span><span class="line">    <span class="c">%theta = [theta1; theta2]</span>
</span><span class="line">    <span class="n">theta</span> <span class="p">=</span> <span class="n">theta</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="o">&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">theta</span> <span class="o">-</span> <span class="n">y</span><span class="p">));</span>
</span><span class="line">    <span class="c">% Save the cost J in every iteration    </span>
</span><span class="line">    <span class="n">J_history</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="p">=</span> <span class="n">computeCost</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="p">);</span>
</span><span class="line"><span class="k">end</span>
</span><span class="line"><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对应的C++实现，向量形式，代码<a href="https://github.com/aluenkinglee/mlclass/blob/master/mlclass
-ex1/gradientDescent.cpp">详见</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="cpp"><span class="line"><span class="cp">#include &quot;gradientDescent.h&quot;</span>
</span><span class="line"><span class="cp">#include &quot;computeCost.h&quot;</span>
</span><span class="line"><span class="k">using</span> <span class="k">namespace</span> <span class="n">mlclass</span><span class="o">::</span><span class="n">ex1</span><span class="p">;</span>
</span><span class="line"><span class="k">namespace</span> <span class="n">mlclass</span><span class="p">{</span>
</span><span class="line"><span class="k">namespace</span> <span class="n">ex1</span><span class="p">{</span>
</span><span class="line">    <span class="c1">//Performs gradient descent to learn theta</span>
</span><span class="line">    <span class="n">mat</span> <span class="n">gradientDescent</span><span class="p">(</span><span class="n">mat</span> <span class="n">X</span><span class="p">,</span> <span class="n">vec</span> <span class="n">y</span><span class="p">,</span> <span class="n">mat</span><span class="o">&amp;</span> <span class="n">theta</span><span class="p">,</span> <span class="kt">double</span> <span class="n">alpah</span><span class="p">,</span><span class="kt">long</span> <span class="n">num_inters</span><span class="p">){</span>
</span><span class="line">        <span class="c1">//number of training examples</span>
</span><span class="line">        <span class="kt">long</span> <span class="n">m</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">n_rows</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">mat</span> <span class="n">J_history</span> <span class="o">=</span> <span class="n">zeros</span><span class="o">&lt;</span><span class="n">mat</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num_inters</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span><span class="line">        <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_inters</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span><span class="line">            <span class="n">theta</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">-</span> <span class="n">alpah</span><span class="o">/</span><span class="n">m</span><span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">t</span><span class="p">()</span><span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">theta</span> <span class="o">-</span> <span class="n">y</span><span class="p">));</span>
</span><span class="line">            <span class="n">J_history</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">computeCost</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="p">);</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">        <span class="k">return</span> <span class="n">J_history</span><span class="p">;</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>有一个事情需要说明一下</strong></p>

<p>梯度下降发的收敛速度比较慢，相比于直接用公式求解$\theta$来说，尤其是当m较小的时候，比如说$m&lt;10000$,
这个时候用公式求解$\theta$比较快，但是大于这个值之后，计算矩阵的逆是花费较大的，此时使用梯度下降法比较理想，而且可以做到分布式计算值，加快求解速度。</p>

<script type="math/tex; mode=display">
\Theta=(X^TX)^-1X^Ty
</script>

<p>关于线性回归就先到这，接下来会记述关于logistic回归等的文章。</p>

<blockquote>
  <p>reference</p>
</blockquote>

<p>1.<a href="https://class.coursera.org/ml-004/lecture">Machine Learning by Andrew Ng(1-2)</a></p>

<p>2.<a href="http://mohu.org/info/symbols/symbols.htm">常用数学符号的 LaTeX 表示方法</a></p>
]]></content>
  </entry>
  
</feed>
